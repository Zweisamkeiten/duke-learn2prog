---
date created: 2022-10-10 10:59
date updated: 2022-10-10 20:23
---

## 编译过程

淡蓝色框表示编写的代码，浅绿色框表示C程序库内置的部分，橙色表示编译过程，白色框表示中间文件，深蓝色框表示最后的可执行文件
![](attachments/Pasted%20image%2020221010105947.png)

### 预处理

预处理器 获取C程序代码文件并与 _header_ 头文件包含在一起, 同时扩展 _macros_ 宏定义.

```c
#include <stdio.h>
#include <stdlib.h>
```

_<>_ 尖括号表示是标准C头文件，自己编写的头文件可使用 双引号来引用 `#include "myHeader.h"`

预处理器指令由 `#` 井号开头，并有规定的语法

头文件主要包含三部分， _函数原型 function prototypes_ _宏定义 macro definitions_ _类型声明 type declarations_

函数原型类似于函数定义，不过没有函数体。它告知编译器函数的在程序中的位置，同时还有返回值与参数的类型。 这些告知允许编译器检查提供的参数个数以及数量是否符合，返回值是否正确。

宏定义 `#define EXIST_SUCCESS 0` (from stdlib.h) 使用常量的宏定义为程序员提供了比直接编写数值常量更多的优势。 一方面，如果程序员需要更改常量，只需更改宏定义，而不是所有使用常量的地方。 另一个优点是命名常量使代码更具可读性。 EXIT_SUCCESS中常量的命名 **return** 给了你一个线索，这里的返回值表明程序成功了。main 的返回值表明您的程序对于运行它的任何程序是成功还是失败。

使用宏定义常量的第三个优点是 _可移植性_ 。 虽然 0 可能表示您的平台上的成功（硬件类型和您拥有的操作系统的组合），但它可能意味着其他平台上的失败。 如果您将常量 0 硬编码到您的代码中，那么它在您的平台上可能是正确的，但可能需要重写才能在另一个平台上正常工作。 相比之下，如果您使用标准头文件中定义的常量，那么当您在新平台上重新编译程序时，它将正常工作——该平台上的头文件会将这些常量定义为正确的值。

## 通过 man pages 来获得库内函数用法

_-S3_ and _printf_. The _-S3_ argument tells _man_ to look in section 3 of the manual, which is dedicated to the C library.

![](attachments/Pasted%20image%2020221010135641.png)
The SYNOPSIS section 列出了 _#include_ 使用的文件，和函数声明原型

屏幕下方从 _DESCRIPTION_ 节开始详细描述了函数的行为。 j k上下移动 d u 上下按页移动 在man page中按 `h` 显示帮助按键

![](attachments/Pasted%20image%2020221010135940.png)
如果我们只输入 _man printf_ 的手册页 _中获得printf 命令_ ，我们会从第 1 节 _(“printf(1)”)_ 。 此页面对应于可执行命令 _printf_ ，它允许您在 shell 中打印内容。
![](attachments/Pasted%20image%2020221010140332.png)
如果我们想要 C 库函数 printf（例如，如果我们正在编程并且需要查找我们不记得的格式说明符），我们需要使用 _-S3_ 显式请求第 3 节选项，因为第 3 节有 C 库参考。

`man man`
![](attachments/Pasted%20image%2020221010141429.png)

![](attachments/Pasted%20image%2020221010141541.png)
查找内容的另一种方法是查看另一页末尾的 SEE ALSO 部分，如果您知道相关但不完全正确的内容。

## 宏定义

标准头文件 limits.h 包含专门用于可移植性的常量。

一个程序需要知道一个 **int 的最大值和最小值**

```c
#define INT_MAX 2147483647
#define INT_MIN -2147483648
```

宏也可以接受参数 宏由预处理器扩展（在编译程序时，甚至在它开始运行之前），并且参数只是以文本形式扩展。 事实上，宏参数没有任何声明的类型，甚至不需要是有效的 C 表达式——只有扩展产生的文本需要是有效的（并且类型正确）。

```c
#define SQUARE(x) x * x
```

`SQUARE(z-y)` => `z-y*z-y` => `z - (y*z) - y`

```c
#define SQUARE(x) ((x) * (x))
```

![](attachments/Pasted%20image%2020221010165705.png)
实际上，预处理器的结果有几千行，因为它包含了 stdio.h 和 stdlib.h 的全部内容，其中还有许多其他函数原型和类型声明。 但是，这些不会影响我们的代码（编译器会知道这些类型和函数存在，但由于我们不使用它们，所以它们无关紧要）。

## Actual Compiler 实际编译器

编译器读取预处理的源代码——其中包含所有指定的文件和扩展的所有宏定义——并将其翻译成汇编。 汇编是人类可读代码的最低级别类型。 在汇编中，每条语句对应一条机器指令。 机器指令对应于非常简单的操作，例如将两个数字相加或将一个值移入或移出内存。

## 编译器错误

- 尝试按顺序从头到尾修复， 修复第一个错误，重新编译代码检查错误是否消失
- 如果错误信息的一部分是非常陌生的，忽略他们然后检查其他错误是否相关。如果相关，理解并修复错误。如果不是，尝试搜索引擎。
- 编辑器能够很好的帮助找到不匹配的大括号和小括号。
- 对错误的修复保持自信。如果不理解错误和如何修复，请找出并确定，而不是随意地改变。

一旦编译器检查完你的代码是否有错误，它将把它翻译成汇编——执行你的程序所说的所需的单个机器指令。 您可以要求编译器 _优化_ 您的代码——转换它以使生成的程序集运行得更快——方法是指定 -O 选项和所需的优化级别。 程序通常在没有优化测试和调试的情况下编译（代码转换使程序很难调试），然后在准备好发布/使用后重新编译优化。 通常，使用 gcc 编译的真实程序在优化时会使用 -O3 进行编译。

## 汇编 Assembling

编译器生成的汇编组装成一个对象文件。gcc调用汇编器把汇编指令从文本/人类可读的格式翻译成处理器可以理解和执行的数字编码。

在这一阶段中很少出现编译错误，除非想要自己添加特定的汇编命令，而导致的编译错误

汇编生成的是一个个目标文件。 这些目标对象文件包含所编译的源文件的机器可执行指令，但不是一个完整的程序。对象文件可能会引用它没有定义的函数(如C库中得函数或写在其他文件中的函数). 可以通过指定 `-c` 使得汇编完成一个对象文件后停止. `gcc -c xyz.c` 会产出 `xyz.o`, `gcc -c xyz.c -o awesomeName.o`

这种停止的能力对于大型程序来说是很重要的，你会把代码分割成多个不同的C文件。将程序分割成大文件主要是为了帮助你将代码分割成可管理的部分。然而，每个源文件都可以单独编译成一个对象文件，然后这些对象文件可以被链接在一起.

如果你改变了一个文件中的代码，你可以只重新编译该文件（为其生成一个新的对象文件），并重新链接该程序，而无需重新编译其他任何源文件。

## 链接 link

使得多个目标对象文件组合在一起,同时包含 _libraries_ 库, 最终产出真正的可执行二进制程序. 对象文件通过 _name_ 来引用函数, 链接器的任务是解析这些引用,找到对应的定义. 如果链接器无法找到,它会报错.

`ld` 链接器错误比较不常见, 如果出现, 可能是因为没有定义该符号, 或者没有包含定义了该符号的目标文件, 或者是该符号只在该目标文件内部可见,而对其他不可见(需要使用static).

如果出现重复定义一个符号的错误, 首先检查是否定义了两个相同名称的函数,然后检查是否 _include_ 了某个文件两次. 最后确保不要只包含了头文件,而头文件中只有函数原型,而没有函数定义.

对于外部函数库,需要使用 `-l` 参数指定.

[Make程序使用](Make程序使用.md)