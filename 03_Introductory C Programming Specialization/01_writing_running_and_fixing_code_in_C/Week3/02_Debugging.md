---
date created: 2022-10-11 17:06
date updated: 2022-10-11 17:49
---

![](attachments/Pasted%20image%2020221011170643.png)
科学的方法来诊断和解决问题

## 科学方法

## 观察一个现象

对现象的观察与程序在某些输入上的行为有关, 这些观察结果通常来自测试用例.

## 提出问题

针对更集中的问题, 例如程序在哪一行崩溃, 为什么程序调用某函数传入的参数为 x = 3, y = -42?

回答问题会产生另一个观察结果, 如果导致了另外一个问题, 则需要重新启动科学方法.

## 收集信息, 应用专业知识

在调试的情况下，您需要收集有关程序中正在发生的事情的信息，并将其与您自己的编程专业知识相结合。 您的专业知识在这里分为两部分。 一个是你对编程的一般知识——我们之前学习过的如何手动执行代码的规则（随着我们介绍更多主题，将继续学习），以及你对正在编写的特定程序的领域知识——预期的行为它的每一部分。

收集信息的最简单方法是插入打印语句（在 C 中，调用 _printf_ ）以显示程序中各个点的各种变量的值。 结果输出可以为您提供有关程序控制流的信息（执行了哪些语句，以及以什么顺序执行 - 如您的打印语句打印其输出的顺序所示），当然还有您打印的变量的值.(**缺点: 1.更改打印的内容需要重新编译并重新运行程序 2. 输出可能会很大, 即使程序在出现错误之前只运行了很短的时间 3. 不能提供许多调试器有的功能 **)

### 调试器

在调试器中运行程序, 可以通过一系列命令来控制程序的执行过程, 并且得到信息. _Emacs_ 可以与 _gdb_ 非常好的结合

运行程序在调试器中, 它会正常运行, 直到 (1) 退出 (2) 崩溃 (3) 遇到断点或者监视点.

在特定行上设置断点, 将会指示调试器在执行箭头到此处时暂停. 断点可以是条件判断的, 可以当条件为真时才暂停.

监视点 当特定的 "box" 改变时暂停

一旦程序停止，可以通过打印表达式的值来检查程序的状态。 调试器将评估表达式，并为您打印结果——为您提供有关程序状态的信息。

调试过程中的一个常见现象：递归观察——获得一些信息（ _例如_ ，查看您为一个变量打印的值）导致您想要一些其他信息（ _例如_ ，打印一些其他变量）。 通常，当您在调查一种现象时（“我的程序在我输入 3 时崩溃......”），您会观察到其他一些现象（“y 是 0 在第 42 行..”），这本身会导致一个值得调查的问题（“这是怎么做到的？发生？”）。

## 形成一个假设

收集所有这些信息的全部目的是帮助形成一个假设。

举个极端的例子，“我的程序坏了”的假设很容易验证，但毫无用处。 假设“我的程序在第 47 行对某些输入除以 0”更有用，但可以改进。 更好的是“如果 _y_ 是奇数且 _z_ 是完美平方，我的程序在第 47 行除以 0。” 这个（人为的）假设是具体而明确的——赋予它两个重要的调试特征。

- 一个好的假设的第一个特征是它是可检验的。它必须对程序的行为做出具体的预测：当我给程序输入满足（ _条件_ ）时，我会观察（ _行为_ ）。
- 一个好的调试假设的第二个特征是它是可操作的. 确定了极端情况，引导我们找到解决问题的途径。

## 接受还是拒绝假设？

一旦我们形成了我们的假设，我们就想对其进行检验。不要误以为您应该经常或急切地接受您的假设而无需任何进一步的测试。 花 10 到 20 分钟来测试一个你“非常确定”的假设比浪费 5 到 10 个小时因为你正在处理错误的信息而把你的代码弄得一团糟要好得多。

### 构建测试用例

假设提出结果时，使用正在考虑的值构建一个测试用例，并查看程序是否表现出这种行为。 另外，构造其他不满足条件的测试用例，看看假设是否过于具体。

### 检查程序的内部状态

使用调试器来检查感兴趣的状态，看看它是否与假设一致。

### 添加断言

编写断言语句来检查不变量
如果 _断言_ 没有失败，驳斥这个假设。 如果 _断言_ 失败，它不仅使我们对假设充满信心，而且使我们的程序失败得更快——它越接近问题的实际根源，就越容易修复。

### 代码检查

在评估是修改当前代码还是丢弃它并重新开始时，您不应该考虑已经投入了多少时间，而应该考虑修复当前代码与从头开始重新设计需要多少时间.

拒绝假设时需要注意的一件事是：代码中可能存在多个错误。 不要被掩盖当前问题的其他错误症状所误导。

程序崩溃的速度比我们预期的要快这一事实 _不应_ 导致我们立即拒绝该假设。 相反，我们必须考虑存在另一个错误的可能性，该错误是由重叠条件触发的。 面对这种可能性，我们有两种选择。

我们可能会采取的一种选择是推迟对第一个错误的调查，同时尝试调试第二个错误。 如果我们可以修复第二个错误，我们可以重新测试这个案例，并发现它与我们最初对第一个错误的假设并不矛盾。

我们的另一个选择是确认我们的怀疑，即行为差异（我们观察到的和我们假设的之间）实际上是不同问题的症状，然后继续测试当前的假设。应该确认有问题的测试用例实际上并没有触发打算测试的情况——也许它没有达到代码中的那个点，或者当它确实达到那个点时没有表现出预期的情况。 一旦确认测试用例实际上并未测试假设，就可以继续处理其他用例。 当然，在修复当前的错误之后，我们应该回到这个案例，找出另一个错误是什么。
