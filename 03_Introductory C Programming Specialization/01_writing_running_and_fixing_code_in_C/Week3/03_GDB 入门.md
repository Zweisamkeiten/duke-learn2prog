---
date created: 2022-10-11 18:45
date updated: 2022-10-12 09:33
---

gcc的 _-g_ 选项请求它包含此调试信息，但如果您特别使用 gdb，则应使用 _-ggdb3_ ，它请求最大数量的调试信息（ _例如_ ，它将包含有关预处理器宏定义的信息）特定于 gdb 的格式。 请注意，如果您分多个步骤（目标文件，然后链接）编译程序， _包含 - ggdb3 。_ 则应在所有步骤中.

要在 _emacs 中_ 使用 _gdb_  ，请使用命令 _Mx gdb_ （即 _ESC x_ 或 _ALT-x_ ，具体取决于您的键盘设置，然后键入 gdb，然后按 Enter）。 此时，emacs 应该会提示您希望如何运行 _gdb_ (“Run gdb (like this):”),，并提供建议的命令行。 通常，emacs 建议的选项就是您想要的； 但是，您可能希望更改要调试的程序的名称（指定为命令行上的最后一个参数）。 对命令行感到满意后，按 Enter 键启动 gdb。

此时，您将得到一个名为 **gdb** 或 **gdb-prog** 的缓冲区（其中 prog 是程序的名称）。 缓冲区名称中的星号表示缓冲区对应于与进程的交互，而不是磁盘上的文件。

**start：** 开始（或重新启动）程序的执行。 后立即停止程序（以接受更多命令）当执行进入到 _main_ 时停止程序。

**run：** 此命令运行程序（可能重新启动它）。 它不会停止，除非遇到其他导致它停止的条件）。

**step：** 将程序推进一个“步”，这与我们在手动执行代码时推进执行箭头的方式非常相似。 更具体地说， _gdb_ 将一直执行，直到执行箭头移动到源代码的另一行，无论是通过转到下一行、响应控制流而跳转还是其他原因。 特别是， step 将进入当前行调用的函数。 该命令可以缩写为 _s_ 。

**next：** 将程序推进一行代码。 但是，与 _step 不同的是，_ 如果当前代码行是一个函数调用， _gdb_ 将执行整个被调用的函数而不会停止。 该命令可以缩写为 _n_ 。

**print：** 打印命令将表达式作为参数，计算该表达式，并打印结果。 请注意，如果表达式有副作用，它们就会发生，并且会影响程序的状态（ _例如_ ，如果你打印 _x = 3_ ，它会将 _x_ 设置为 3，然后打印 3）。 您可以 _放置/x_ 之后 _在print_ 以获取以十六进制格式打印的结果。 此命令可以缩写为 _p_ （或 _p/x_ 以 _十六进制_ 打印）。 每次打印表达式的值时， _gdb_ 都会记住其内部变量中的值，这些变量名为 $ 1  $2  等（您可以知道它使用了哪一个，因为它会在打印值 _——例如，$ 1 = 42_ )。 如果您想稍后使用这些值，您可以在其他表达式中使用这些  $ 变量。 _gdb_ 还有一个特性可以让你从一个数组中打印多个元素——如果你把 _@number_ 放在一个左值之后， _gdb_ 将打印从你命名的位置开始的数字值。 这个特性对数组最有用——例如，如果 a 是一个数组，你可以这样做 `p a[0]@5` 的前 5 个元素 _打印a_ 。

**display：** display _命令_ 接受一个表达式作为参数，并在每次 _gdb_ 停止并显示一个提示时显示它的值。 例如 display _i_ 之前评估并打印 _i_ 将在每个 _(gdb_ ) 提示 。 您可以缩写此命令 _disp_ 。

如果您在没有输入任何命令的情况下按回车， _gdb_ 将重复您输入的最后一个命令。 当您想  连续多次 _使用step_ 或 _next时，此功能最有用。_

请注意，如果您需要将命令行参数传递给您的程序，您可以在 _启动_ 或 _运行_ 命令之后编写它们（ 例如，`run someArg anotherArg` `start someArg anotherArg` ），或者您可以使用 _set args_ 来设置命令行参数。

## 检查程序的状态

`print` 和 `display` 命令能够用于观察一个表达式的值

gdb 允许检查当前的堆栈帧集, 并且可以在它们之中上下移动.
`backtrace` 命令列出所有栈帧(stack frames) (当前栈帧在最上方, `main`在最下方). 因此可以查看哪些函数调用将程序带到当前位置. 还列出了每次调用所在的行(或者当前帧的执行箭头所在的位置)
`print` gdb 会使用当前 scope(可见范围)中的变量. gdb可以选择不同的帧,通过 `up` 和 `down` 移动到指定的栈
当程序因为一个 `assert` 终止时, gdb 会停在深层的 C 库中, 处理 `assert` 的代码处. 可以通过 `up` 来向上移动栈帧以至于回到自己的代码之中.

`info` 命令

- `info frame` 描述当前帧的内存层级
- `info types` 描述当前程序中的类型
- `help info`

## 控制执行

`next` 和 `step` 命令可以在程序中步进.

可以设置断点, `break`, `break [linenumber/function_name]`, 在 emacs 可以按 `C-x space` 设置断点在当前点. 同时也可视在特定内存地址设置断点. 当设置了一个断点, _gdb_ 会分配给其一个数字, 可以用于之后断点相关命令的区分.

当设置完成断点, 可以 `run` 程序 (或者 `continue` 如果程序已经启动). 程序将运行直到遇到断点(或者其他会造成停止的情况). 在停止状态,可以继续输入其他命令,例如检查程序状态,设置更多断点然后continue.

默认情况, 断点是无条件判断的断点. 可以设置条件判断表达式 `break 7 if i == 250000` 或者如果断点已经存在且被分配为 `1`, 可以使用 `cond 1 i == 250000`

如果输入一个没有表达式的 `cond` 命令, 它会使得该断点变为无条件判断.

可以 _enable/disable_ 断点, 禁用的断点依然存在(可以以后重新启用) `enable/disable [point_number]`. 可以 `delete` 断点, `delete [point_id]`. 可以使用 _info breakpoints_ 命令（可以缩写为 _ib_ ）查看当前断点的状态。

`clear [function_name]` 删除断点

另外两个用于控制程序执行的有用命令是 _until_ ，它导致循环执行直到它完成（ _gdb_ 在循环后的第一行停止）和 _finish_ （可以缩写为 fin），它完成当前函数— _即_ ，导致执行直到当前函数返回。

## 观察点

watchpoint - 观察点 当特定表达式的值发生变化时让 gdb 停止的能力

可以写 _watch i，_ ，就会导致 _gdb_ 停止 _只要i_ 的值发生变化 。 当 _gdb_ 停止响应观察点时，它将打印表达式的旧值和新值。

当遇到与指针相关的问题并且变量的值通过别名发生变化时，观察点可能是一个特别强大的工具。

给观察点设置别名(因为其更改会超过范围, 可能会有不同的变量名). 例如观察 `*p`, 但 _p_ 是一个局部变量，其作用域在值更改之前结束。 每当我们遇到这样的问题时，我们可以 _print p_ ，它会给我们一个 _gdb_ 变量中的指针（ _例如 $6_ ）

然后我们可以使用那个 _$_ 变量（它永远不会超出范围——它一直存在到我们重新启动 _gdb_ ) 来设置我们的观察点： watch _*$6_ 。

## 信号
每当程序收到信号时， _gdb_ 都会停止程序并提供控制。

在调试过程中会出现三个特别常见的信号。 第一个是 SIGSEGV，表示分段错误。 如果您的程序出现段错误，那么只需在 _gdb_ 中运行它就可以帮助您收集有关正在发生的事情的大量信息。 当段错误发生时， _gdb_ 将停止，您的程序将在发生段错误的行上。 然后您可以开始检查程序的状态（打印出变量），看看出了什么问题。

另一个常见的信号是 SIGABRT，它发生在您编写程序调用 _abort()_ 失败 _或assert_ 时。 与段错误一样，如果您的代码未通过断言，那么在 gdb 中运行它可能非常有用——您将在 _断言_ 导致程序中止的点获得程序的控制权，并且（在返回几帧后回到您的自己的代码），看看问题发生时到底发生了什么。

另一个有用的信号是 SIGINT，它在程序中断时发生 _——例如_ ，通过用户按 Control-c（在 emacs 中，您必须按 Cc Cc: Control-C 两次）。 如果您的程序陷入无限循环，您可以在 _gdb_ 中运行它，然后在一段时间后按 Control-c。 然后，您可以看到程序在哪里，以及它在做什么。 不能保证您在正确的位置（您可能会在程序进入无限循环之前中断程序），但如果您等待足够长的时间，您通常会到达您想要的位置。 然后您可以看到正在发生的事情，以及为什么您没有得到您想要的行为。