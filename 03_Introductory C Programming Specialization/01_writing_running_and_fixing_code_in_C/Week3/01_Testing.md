---
date created: 2022-10-11 13:16
date updated: 2022-10-11 14:07
---

我的测试技巧

```shell
for i in -2 -1 0 1 2 3 4 5 6 7 8 9 10 1.1 str 123 123str;do ./isPrime-correct $i; done > correct
for i in -2 -1 0 1 2 3 4 5 6 7 8 9 10 1.1 str 123 123str;do ./isPrime-broken2 $i; done | diff - correct                                                                           

```

## Black Box Testing 黑盒测试

- 只需考虑对函数期望的行为以及结果,而不需要任何实现细节
- 黑盒测试不意味着临时考虑几种特殊的情况, 而是尽可能地去暴露程序中的错误.
- 不仅要设计简单的测试用例,还要设计测试极端情况
- 一些程序员提倡测试优先的开发方法。 一个优点是，如果在开始之前编写了一个全面的测试组合，在实现代码之后就不需要在测试花费时间。 另一个优点是，通过提前考虑极端情况，您在开发和实现算法时出错的可能性较小。

![](attachments/Pasted%20image%2020221011130914.png)

## 设计测试的实践经验

- 测试用例覆盖所有错误情况. 考虑所有程序无法处理的输入.例如程序需要一个数字, 则考虑字符串或者数字字符混合的字符串.
- 一定要测试"过多"和"过少". 如果需要N个, 则最好测试一下比N多一个和少一个的情况
- 每一个测试用例只能包含一种错误退出的情况.
- 准确地在有效性的边界进行测试。因为常见的“一个偏移”错误——也许在应该写 <= 时写了 <, 或应该写 >= 时写了 > 或类似的东西。 如果使用恰好在边界处的值进行测试，会发现这些错误。
- 仔细考虑是否存在任何特殊情况，其中一个特定的输入值（或一组值必须被异常处理）。
- 仔细考虑需求，并考虑某些内容是否可能被误解、容易被错误实现，或者是否存在看似正确的变化。例如递减序列,需要考虑 7 6 6 5 4等其中有相等的非严格递减序列.
- 考虑类型。64位整数位置而使用了32位整数, 浮点数位置使用了整数类型

**考虑所有主要的输入类别，并确保涵盖它们。**

- 对于数字输入，这些通常是负数、零和正数。 "1"通常也是一个很好的数字，可以确保你覆盖
- 对于数据序列，您的测试应涵盖空序列、单个元素序列和具有许多元素的序列。
- 对于字符：小写字母、大写字母、数字、标点符号、空格、不可打印字符
- 对于许多算法，您应该考虑一些特定于问题的类别。 例如，如果您正在测试与素数相关的函数（例如，isPrime），那么您应该考虑将素数和复合（非素数）数作为要涵盖的输入类别。
- 当您结合两种方式对数据进行分类时，请涵盖所有组合。 例如，如果你有一个数字序列，你应该用一个空列表进行测试，一个元素序列为 0，一个元素序列为负数，一个元素序列为正数，并且每个元素都为负数，零和正数出现在您的多元素序列中。
- 上述规则的一个重要推论是，如果您的算法给出了一组答案，您可以在其中列出所有可能的答案（真/假、来自枚举的值、来自特定集合的字符串等），那么您的测试用例应该确保你至少得到每个答案一次。 此外，如果还有您认为重要的其他条件，您应该确保您获得了每个条件的所有可能答案。 例如，如果你得到一个是/否的答案，对于一个数字输入，你应该用一个给出“是”的负数、一个给出“否”的负数、一个给出“是”的正数、一个给出“否”的正数进行测试，和零[零只是一个输入，将有一个答案]。
- 所有这些建议都是一个很好的起点，但测试最重要的是仔细考虑——想象所有可能出错的事情，仔细考虑如何测试它们，并确保你的测试用例实际上是在测试你认为他们正在测试什么。

## 白盒测试 White Box Testing

- 白盒测试需要考虑的是测试覆盖率- 描述测试用例覆盖代码不同行为的程度
- 白盒测试与黑盒测试互补(从一组黑盒测试用例开始,实现算法,然后创建更多测试用例以达到所需的测试覆盖率水平)

```c
int aFunction(int a, int b, int c) {
	int answer = 0;
	if (a < b) {
		answer = b - a;
	}
	if (b < c) {
		answer = answer * (b - c);
	}
	else {
		answer = answer + 42;
	}
	return answer;
}
```

- 语句覆盖
  - 函数中的每条语句都被执行 例如: 只提供 `a=1, b=2, c=3` 的测试用例的话, 第10条语句将无法被覆盖,因此需要增加其他测试用例,使得该语句也有被执行
- 决策覆盖
  - 语句覆盖率是最小的起点, 之后对于例如if语句,其表达式为假的情况也需要进行覆盖. 例如 a > b的情况
  - 如果有 switch/case 语句, 则需要为每个选择都构造至少一个测试用例 和隐式的 default 用例
  - 全面了解决策覆盖的范围, 需要将其可视化. 控制流图(CFG), 有向图, 节点是基本块(框),边表示控制流箭头可以移动的可能方式(箭头). 基本块是必须以"全有或全无"方式执行的连续语句,即执行箭头在基本块中执行时不会跳入或跳出基本块.CFG 显示了控制流箭头如何从一个基本块移动到下一个基本块。
  - ![](attachments/Pasted%20image%2020221011133946.png)
  - 一次为一个函数绘制 CFG。 我们还可以画出执行箭头如何 _之间_ 在函数 移动； 这称为 _调用图_ 。
  - 决策覆盖对应于拥有一套覆盖图中每条边的测试用例。
  - ![](attachments/Pasted%20image%2020221011134113.png)
- 路径覆盖
  - 更强大的测试覆盖类型是 _路径覆盖_ 。 为了实现路径覆盖，我们的测试用例必须跨越控制流图的所有可能的有效路径（按照箭头的方向）。
  - 例如上图中, 尚未涵盖一条路径（以红色显示）。 该路径对应于 a<b 为假，但 b<c 为真的情况。
  - 提供决策覆盖的测试用例分别测试了这些条件中的每一个，但没有一个测试同时测试这两个条件——我们的执行将遵循红色路径。

更高级别的覆盖率让我们对代码的正确性更有信心，但代价是更多的测试用例。如何选择正确的测试覆盖率呢？ 与许多事情一样，答案是“视情况而定”。 这个决定的第一个方面是“你需要对你的代码有多大的信心？”

手动对算法进行初步测试,则语句覆盖率是比较合理的选择

如果正在测试一个将在您完成测试时部署的关键软件，那么仅实现语句覆盖率将是严重不足的。 在这里，可能希望的目标不仅仅是实现路径覆盖的最低要求。 不幸的是，没有多少测试可以确保代码是正确的——它只会增加我们对它的信心。

## 生成测试用例

测试的一个困难来自于想测试没有想到的案例
解决此类问题的一种方法是根据某种算法生成测试用例。另一种可能性是随机生成（伪）测试用例（毫不奇怪，称为 _随机测试_ ）。

以算法方式生成测试用例的一个棘手部分是我们需要某种方法来验证答案.在极少数情况下，编写可用于相互检查的两个版本的函数可能很有吸引力。 当您编写复杂的实现以实现高性能时，这种方法是合适的，但您也可以编写更简单（但速度较慢）的实现，您更容易确定其正确性。 在这里，在许多测试用例中实现两者并针对更简单/更慢的算法测试复杂/优化算法是有意义的。

可能能够测试系统的其他属性，以增加我们对其正确性的信心。 例如，假设我们正在编写软件来模拟一个网络，该网络将消息从源路由到目的地（如何实现的细节超出了我们目前所学的技能，但这对于示例并不重要）。 即使不知道正确的答案，我们仍然可以测试系统的某些属性是否得到遵守：我们发送的每条消息都应该传递到正确的目的地，传递应该只发生一次，不正确的目的地应该接收到消息，传递应该在某个合理的时间范围内发生，依此类推。

检查这些属性并不能检查程序是否给出了正确的答案（ _例如_ ，它可能通过不正确但可行的路径路由消息），但它会检查这些测试用例中的某些类别的错误。 与所有测试用例一样，这增加了我们对程序正确的信心，但并不能证明它是正确的。

这个附加程序称为 _测试工具_ ——它是您编写的用于运行和测试代码主要部分的程序。 开发此类基础设施可能很耗时，但通常是一项很好的时间投资，尤其是对于大型项目。

## 断言

_assert(expr);_ 检查 _expr_ 是否为真。 如果它是真的，那么什么都不会发生，并且继续正常执行。 但是，如果 _expr_ 为假，则它会打印一条消息，说明断言失败，并中止程序——无论它在哪里，都会立即终止它。

1. 检查最终结果
2. 检查程序执行过程的 _不变量_ 保持不变.

即如果我们的程序有错误，我们希望它 _快速失败_ ——也就是说，我们希望程序在错误发生后尽快崩溃。 错误发生后程序运行的时间越长，给出错误答案的可能性就越大，调试也就越困难。 理想情况下，当我们的程序出现错误时，我们将在它之后立即出现断言失败，准确指出问题所在以及问题所在。

减速可以忽略不计，尤其是在快速的现代计算机上。 在许多情况下，1-2% 的性能并不重要

在某些性能关键情况下，速度很重要。 对于这些情况，您可以将 _-DNDEBUG_ 选项传递给编译器以关闭优化代码中的断言。 对于所有其他情况，通常建议保持它们处于活动状态。

## 代码审查

1. 正确性测试永无止境
2. 测试只会暴露程序上的问题,却无法提高代码可读性, 命名规范, 代码注释等方面

在代码审查中，另一位熟练的程序员审查您编写的代码，寻找您可能犯的错误。 这样的审查是解决“如何测试你没有想到的问题”问题的另一种方法——审查者为代码带来了新的视角，并且可能会发现你没有考虑过的关注领域。 与其他形式的测试相比，代码审查有一个很好的优势：通常当您的审查者发现问题时，她可以提出解决问题的步骤。

代码审查的一种形式是 `code walk-through`逐行审查，程序员在其中向审查者解释算法和代码。 通常，审阅者熟悉解决问题所需的问题和算法，因此侧重于代码本身。 程序员逐行浏览代码，向审阅者解释每一行的作用以及它存在的原因。 如果审阅者不熟悉问题/算法，则演练过程可以从程序员引导审阅者完成编程过程的早期步骤开始——甚至可能从第 1 步开始：自己解决问题的一个实例。
