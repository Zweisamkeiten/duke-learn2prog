---
date created: 2022-10-15 11:24
---

在尾递归中，**递归调用**是函数在返回之前所做的最后一件事。 也就是说，对于尾递归函数 f，唯一的递归调用将在 **return f (...) 的上下文中找到；** ——一旦对 f 的递归调用返回，该函数立即返回其结果，无需任何进一步的计算。

_尾调用_ ——如果调用者在被调用函数返回后立即返回，则函数调用就是尾调用，无需进一步计算。 换句话说：如果函数 _f_ 调用函数 g，那么对 _g_ 返回后唯一做的事情 是返回 _g的返回_ 的调用是尾调用，如果 _f_ 在 _g_ 是立即返回 _g_ 的返回值（或者如果 _f_ 的返回类型是 **void** ， 那么返回）。 这两个概念联系在一起，因为递归函数是尾递归，当且仅当它的递归调用是尾调用。

```c
int factorial_helper (int n, int ans) {
	//base case
	if (n <= 0) {
		return ans;
	}
	//recursive call is a tail call
	//after recursive call returns, just return its answer
	return factorial_helper (n - 1, ans ∗ n);
}
int factorial (int n) {
	return factorial_helper (n, 1); //tail call
}
```

尾递归 _辅助函数_ ——我们的主函数调用这个函数来完成大部分工作。 辅助函数在尾递归中很常见，但也可能出现在其他上下文中。 
辅助函数为它在递归时建立的答案采用了一个额外的参数。 主函数只是调用传入 _n_ 和 1 的函数。
注意递归调用是尾调用。 该调用返回后发生的所有事情都是立即返回其结果。 请注意，阶乘的尾递归版本的工作量不亚于原始递归版本。 在最初的递归版本中一系列乘法发生在递归调用**之后**，数字的阶乘是由每次递归调用 。 在尾递归版本中，此乘法发生在递归调用**之前** 。 运行积存储在尾递归函数的第二个参数中。

许多编译器将进行的优化，以使尾递归函数更高效。 当编译器执行“尾递归消除”时，它会将当前帧重用于尾递归调用。 因为函数在尾调用完成后立即返回，编译器认识到帧中的值将永远不会被再次使用，因此可以覆盖它。

## 尾递归和迭代的等效性

```c
int factorial (int n) {
	int ans = 1;
	while (n > 0) {
		ans = ans * n;
		n--;
	}
	return ans;
}
```

尾递归消除优化，尾递归实现甚至不创建任何新帧（与迭代实现相同）——它只是重新使用现有帧。

任何我们可以用迭代编写的算法，我们都可以简单地转换为尾递归，反之亦然。 智能编译器会将尾递归代码和迭代代码编译成完全相同的指令。

尾递归和迭代的等价性对于函数式编程语言尤其重要。 在纯函数式语言中，一旦创建值，您就不能实际修改它（至少从语言的角度来看不是：如果编译器可以断定您永远不会使用它，那么编译器可以自由地重用同一个“盒子”再次）。 因此，没有循环（通常需要修改变量来改变条件），而只有递归函数。 您通常将其编写为循环，而只是将其编写为尾递归函数。

掌握一门函数式编程语言很重要.帮助我们以不同的方式思考问题.

## 相互递归
两个及以上函数互相调用. 记住递归函数就是抽象整个执行过程以解决小规模的相同问题直到接近其base case基本情况. 

```c
int isOdd (unsigned int n); //prototype for isOdd
int isEven (unsigned int n) {
	if (n == 0) {
		return 1;
	}
	if (n == 1) {
		return 0;
	}
	return isOdd (n - 1); //complicated step: abstract into a function
}
int isOdd (unsigned int n) {
	if (n == 0) {
		return 0;
	}
	if (n == 1) {
		return 1;
	}
	return isEven (n - 1); //already have a function to do this step
}
```

相互递归函数有许多重要用途. 一种常见的用途是 _递归下降解析_ 。 解析是分析输入文本以确定其含义的过程。 递归下降解析器通常通过编写许多函数（每个函数解析输入的特定部分）来编写，然后相互递归以完成它们的工作。 我们不会在这里详细介绍，但是您可以通过考虑 C 函数及其参数来想象相互递归的本质——例如，如果您正在为 C 编译器编写解析器。

在高层次上，要解析函数调用 ( `f(arg1, arg2,...)`)，您将编写一个函数 _parseCall。_ parseCall 将 _读取函数名称和左括号_，然后重复调用另一个函数 _parseExpression_ 来解析每个参数（它必须是一个表达式），并检查参数后面是否跟有逗号或右括号。 parseExpression _函数本身可能会_ 遇到函数调用，在这种情况下，它需要调用 _parseCall_ 。 如果被解析的文本看起来像这样 _f(3,g(42), h(x,y,z(1)))_ 就会发生这种情况——f 的一些参数本身就是函数调用，事实上， h 的参数之一也是函数调用。

这样的解析通常会导致相互递归定义的数据结构——这意味着您有两个（或更多）类型，它们递归地相互引用。 对相互递归的数据结构进行操作的算法通常很自然地适用于相互递归的实现。 当然，相互递归的数据结构也可能出现在各种其他环境中。

## 递归理论

递归与归纳的数学证明技术有很强的关系。 如果你需要快速复习 _归纳_ 法，这是一种让我们证明 **∀ x ∊ ℕ.p(x)** ，其中 p(x) 是关于 x 的某个命题。 （ _翻译_ ：我们想证明 p(x) 对于所有自然数 x 都是正确的。）归纳证明从证明基本情况 p(0) 开始。 然后通过展示归纳情况进行证明——证明 **∀ n ∊ ℕ。 p(n)** → **p(n+1)** （弱归纳）或 **∀ n ∊ ℕ。** ( **∀ x ∊ ℕ <n.** **p(x))** → **p(n+1)** （强归纳）。

两者之间的相似之处——有一个基本案例，一个递归/归纳案例处理较小的值——并不是随机巧合。 我们的递归函数 _为所有_ 可能的输入计算一些答案（具有某些属性）。 递归函数的工作原理是假设递归案例正确工作，并使用该事实使当前案例正确工作——很像归纳案例假设命题适用于较小的数字，并使用该事实来证明“当前案例” “ 数字。 事实上，如果我们想证明一个递归函数是正确的，我们将通过归纳来进行——归纳证明的结构将反映递归函数的结构。