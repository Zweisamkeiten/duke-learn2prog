---
date created: 2022-10-15 10:00
---

- 递归函数 调用其自身
- 递归函数包含一个基本情况 - 某个情况下它给出结果而不需要调用其自身
- 正确的递归调用会使得进度情况越来越接近基本情况
- 递归不慢, 但是不合理的低效算法会导致性能问题.

编写 _fib_ 算法的方式重复了工作——我们的实现将计算 _fib_ ( _44_ ) 两次， _fib_ ( _43_ ) 3 次， _fib_ ( _42_ ) 5 次， _fib_ ( _41_ ) 8 次， … _fib_ ( _1_ ) 1,836,311,903 次， _fib_ ( _0_ ) 1,134,903,170 次！ 总体而言，评估 _fib_ ( _46_ ) 总共需要 5,942,430,145 次对 Fibonacci 函数的调用。

![](attachments/Pasted%20image%2020221015104812.png)

可以重新考虑我们的算法，从 0 和 1 开始（计算 _fib_ ( _2_ )，然后是 _fib_ ( _3_ )，然后是 _fib_ ( _4_ )，等等）——在任何一步，我们只需将它们相加前两个值（我们 _计算fib_ ( _5_ )计算的任何内容相加来 _通过将我们刚刚为fib_ ( _3_ ) 和 _fib(_ _4_ )）。

![](attachments/Pasted%20image%2020221015105528.png)
![](attachments/Pasted%20image%2020221015105548.png)

在不改变底层算法的情况下解决性能问题的另一种方法是 _记忆_ 化——保留一个我们已经计算过的值的表，并在重新计算之前检查该表以查看我们是否已经知道答案。