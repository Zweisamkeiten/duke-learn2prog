---
date created: 2022-10-14 22:15
date updated: 2022-10-14 23:19
---

## 缓冲区溢出

![](attachments/Pasted%20image%2020221014221123.png)

永远不应该使用 `gets`, 因为它无法指定它应该读入固定大小缓冲区的最大字节数.

底层堆栈框架的布局非常特定于平台，但是这种攻击可以适应大多数平台。这条线将框架与“主要”分开, 从框架的底部到其顶部的颜色。
“Main”被 C 库的一部分调用。该帧中可能有除零以外的值，但它们是什么并不重要。

在这里，我们有一个“argv”，它有一个八字节的指针。它指向此处未显示的字符串数组。然后，我们有“argc”，它是一个四字节整数，其值为 1。然后，我们有一个八字节指针的返回地址。这指向 C 库代码中的某个位置，就在它称为“main”之后。C 库该部分中的代码将调用“exit”，传入“main”的返回值。
![](attachments/Pasted%20image%2020221014221524.png)

现在，我们将在“main”的开头开始执行。

我们声明输入将是堆栈中接下来的 12 个字节。然后我们调用 C 库中某处的“gets”。程序员希望用户输入的内容少于 12 个字节，例如“Hello”，它将这些字节写入输入的第一部分。但是如果输入的长度超过 12 个字符怎么办？“Gets”不知道实际分配了多少空间给输入，所以它只会继续将数据写入堆栈上的下一个地址。请注意，返回地址在堆栈上。如果你覆盖它会发生什么？您将更改剩余返回的东西。
![](attachments/Pasted%20image%2020221014221808.png)

前 12 个字节没有问题。正如我们所希望的那样，它们被写入输入。但是这个输入长于 12 个字节。输入的接下来的 8 个字节会覆盖返回地址。请注意，我们覆盖它的值看起来像是指向堆栈的有效指针。事实上，那个指针就是“argc”，这很重要，因为我们继续覆盖“argc”并覆盖“argv”，然后覆盖彩色框中的数据。注意，我们终于读到了一个具有数值的新行“hex0A”，然后“获取”写入和空终止符，其值为“hex00”。现在，“gets”完成了，所以它返回到“main”，它从输入中打印，直到找到一个空终止符。所以，它会打印一些字母，然后是一些不可打印的字符。现在，我们准备从“main”返回。通常，我们的程序会退出，但那是因为它会返回退出程序的 C 库代码。但是，由于我们破坏了返回地址，我们将返回它指定的地址并继续在那里执行代码。该地址就在堆栈上，包含邪恶黑客输入的精心制作的数据。所以，当我们回到那里时，我们将开始执行任何与黑客输入的值相对应的指令。这组特定的指令是为了执行命令外壳而设计的。想象一下，如果代码是网络服务的一部分，并且攻击者能够从他们的缓冲区溢出中获取系统上的 shell。
然后他们可以执行他们想要的任何命令。这个故事的寓意是永远不要使用“gets”and be careful to never allow buffer overflows.

## 格式化字符串攻击

_printf_ 采用格式字符串（带有 _%_ 符号的字符串表示格式转换，例如 _转换十进制整数的%d_ ），然后是要转换的值的适当数量的其他参数。 每当用户可能会影响格式字符串以引入额外的格式转换时，就会出现格式字符串漏洞。

作为一个简单的例子，假设有一个 _readAString_ () 函数从用户那里读取一个字符串。 考虑以下易受攻击的代码，它尝试读取字符串然后将其打印回来：

```c
// BAD CODE: DO NOT DO!
char * input = readAString();
printf(input);
```

如果攻击者输入带有 _%_ 符号的字符串，它可能会导致程序以不应该的方式运行。 请注意，上述代码中对 _printf_ 的调用使用从用户读取的输入作为格式字符串。 即使没有用于转换格式说明符的参数， _printf_ 也不会被阻止。 如果用户输入包含 _%_ 格式化转换， _则printf_ 将获取这些参数 _应该_ 位于的数据，按照指示对其进行格式化，然后打印它们。 至少，攻击者可以通过在其输入中放置 _%d_ 或 _%s_ 格式说明符来使程序泄露数据。

就是所谓占位符的变量没有给定, 但也可以通过这样获取其他位置的变量的值.

此攻击揭示的信息取决于 _printf_ 查找这些额外参数的位置中存在哪些信息。 更糟糕的是， _printf_ 有一个格式说明符 ( _%n_ )，它将到目前为止打印的字符数写入由一个的 `int *` 作为适当参数传递 指定的内存位置。 聪明的攻击者可以利用这种格式转换以恶意方式修改程序的内存，改变其行为，并可能执行任意代码。

正确方法 将 _printf_ 与用户的字符串输入（或可能受到影响） 是使用 _%s_ 转换：

```c
// CORRECT CODE
char * input = readAString();
printf("%s", input);
```

gcc 会给予一个警告, 告知格式化字符串不是一个字面量, 而且没有格式化对应的参数(例如printf只有一个唯一的参数,格式化字符串). 但是, 它在有其他参数的时候就不会在警告了.  理由是: 如果没有东西需要转换, 需要为字符串使用 "_%s_". 但是, 有时您可能有一个参数并想要计算格式字符串。

```c
const char * fmt = "%d\n";
if (printInHex) {
	fmt = "%x\n";
}
printf(fmt, someNumber);
```

确定格式字符串是 _%d\n_ （将数字打印为十进制）或 _%x\n_ （将数字打印为十六进制），其中任何一个都可以打印 someNumber（我们假设它是一个 **int** ）。 但是，当我们编写计算格式字符串的代码时，我们必须小心，以确保用户不会以恶意方式影响它。

格式字符串漏洞属于更大的安全漏洞类别，其中程序使用 _未经处理的输入_ 。 更一般地说，如果程序以某种特殊字符的方式使用字符串，则必须注意删除或转义从用户读取的输入中的这些字符。 对于 _printf_ 的格式字符串，这些特殊字符是 _%_ 符号。 如果我们想让用户控制格式字符串，当（且仅当）我们注意首先 _清理_ 字符串时，我们可以安全地做到这一点——迭代它并修改 _%_ 符号以删除它们的特殊含义（ 即 ，通过删除它们或将它们转换为 `%%`  — 打印文字百分号的格式说明符）。 更简单（因此更不容易出错） _然而，在 printf 的情况下，没有理由采用这种方法——简单地使用%s_ 说明符来逐字打印字符串 。 如果我们需要依赖于用户的格式说明符，我们的代码应该自己构建格式字符串。 #newget

但是，在其他情况下，我们可能希望从用户那里读取字符串并将其包含在字符具有特殊含义的某些上下文中。 最常见的两种情况是传递给命令外壳的命令和传递给数据库的信息。

命令 shell 认为许多字符是特殊的，但一个特别危险的字符是 (反引号) 用反引号括起来的文本作为它自己的命令执行。 假设我们的程序从用户那里读取一些输入，并将其作为参数传递给 shell 命令——也就是说，它执行 _someCommand_ _stringFromUser_ 。 如果恶意用户输入 `rm -rf *`，那么命令 shell 将执行反引号扩展，并运行命令 _rm -rf *_ ，这将清除当前目录中的所有文件。 尽管此命令具有破坏性，但更阴险的用户可以找到更好的命令来执行——这些命令使他们能够访问系统以获取和/或修改信息。

数据库使用不当也会出现类似的问题，程序将 SQL 命令作为字符串传递给数据库。 我们不会深入 SQL 的细节，但想象一下我们可以在不完全理解它们的情况下说明这一点。 假设程序要运行命令 _SELECT *_ from _Users WHERE name='strFromUser_ '，其中 strFromUser 是从用户那里读取的字符串（ _例如_ ，您向他们询问了他们的用户名，并且他们已经输入了该用户名）。 如果我们不小心，用户可能会键入一个 **'** （终止与名称匹配的文字）和一个 **;** 结束当前命令，然后是他选择的任意命令。 这样的漏洞允许攻击者随意修改数据库中的信息。 网络漫画 xkcd 有一个关于这个主题的漂亮漫画：http: [//xkcd.com/327/](http://xkcd.com/327/) 。

请注意，清理输入是一项必须小心执行的任务。 捕获一半案例的清理功能几乎不比不清理好 - 聪明的攻击者会尝试所有可能的特殊字符，并最终找到允许她破坏系统的那个。 每当您需要清理输入时，首先要做的最好的事情是检查是否已经有由专家编写的功能可供您使用。 例如，一些数据库接口已经准备好语句，允许您使用 _?s_ 编写 SQL 查询来代替各种输入，将值绑定到这些输入，然后数据库库确保不存在输入清理问题。
