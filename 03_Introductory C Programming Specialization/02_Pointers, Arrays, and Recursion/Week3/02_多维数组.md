---
date created: 2022-10-14 16:27
date updated: 2022-10-14 17:22
---

## 声明

用多组方括号声明它们，每组表示相应维度的大小

```c
double myMatrix[4][3];
```

_myMatrix_ 占用 (4 * 3 * **sizeof** ( **double** )) 字节的内存

![](attachments/Pasted%20image%2020221014162740.png)

元素在内存中是连续的

## 索引

`myArray[2][1] = 3.14;` 。 但是，我们应该注意 `myArray[2]` 不是左值，就像 _myArray_ 不是左值一样.

求值的指针 `myArray[2]` 实际上并未存储在任何地方，它只是通过来自 _myArray_ 的指针算术计算得出的。

## 初始化

```c
double myMatrix[4][3] = { {1.0, 2.5, 3.2}, //elements of myMatrix[0]
						{7.9, 1.2, 9.9}, //elements of myMatrix[1]
						{8.8, 3.4, 0.0}, //elements of myMatrix[2]
						{4.5, 9.2, 1.6} }; //elements of myMatrix[3]
```

可以省略第一个维度，因为编译器可以确定初始化器中有多少元素

```c
//also legal: removed the 4 from the []

double myMatrix[][3] = { {1.0, 2.5, 3.2}, //elements of myMatrix[0]
						{7.9, 1.2, 9.9}, //elements of myMatrix[1]
						{8.8, 3.4, 0.0}, //elements of myMatrix[2]
						{4.5, 9.2, 1.6} }; //elements of myMatrix[3]
```

不能省略第二维的大小规范。 在为函数声明参数时，您也可以省略第一个维度的大小，但不能省略任何其他维度的大小。

多维数组不限于二维。 对于更多维度，编写额外的 `[ ]` 每个额外维度的大小

## 指针数组

使用显式保存指向其他数组的指针的数组来表示多维数据

```c
double row0[3];
double row1[3];
double row2[3];
double row3[3];
double * myMatrix[4] = {row0, row1, row2, row3};
```

![](attachments/Pasted%20image%2020221014163454.png)

直接声明初始化多维数组与指针数组相比, 前者， `myMatrix[2]` 计算为指向数组的指针，该数组是矩阵的第二行。 后者， `myMatrix[2]` 的计算结果为指向的**double** 矩阵的第二行第一列中的指针

存在一些显着差异。 首先，在这个指针表示数组中，指向行的指针显式地存储在内存中。 因此，评估 `myMatrix[i]` 实际上涉及从内存中读取一个值，而不仅仅是计算偏移量。 这种差异对性能有影响.

显式存储指向矩阵行的指针允许用这个表示做一些不能用第一个表示做的事情。 首先，不限于让每一行与其他行的大小相同。 其次，在指针表示的数组中， `myMatrix[i]` 是一个左值（回想一下，如果我们只是声明一个多维数组，它不是）。 因此，如果我们愿意，我们可以更改指针指向的位置。 第三，我们可以让两行指向完全相同的数组（相互混叠）。

## 不兼容

两种多维数组表示方式不兼容 且不能相互转换(隐式 强制cast)

![](attachments/Pasted%20image%2020221014171235.png)
强制类型转换后 arr 指向的地址解释为一个 int 型 指针, 因此是 8个字节. 而原先储存的是按每四个字节一个整型. 因此 `arr[0] = 0x00000001000000`
![](attachments/Pasted%20image%2020221014171651.png)

![](attachments/Pasted%20image%2020221014171950.png)

![](attachments/Pasted%20image%2020221014172254.png)

## 字符串数组

字符串数组本质上是一个多维字符数组

```c
char strs[3][4] = {"Abc", "def", "ghi"};
char chrs[3][3] = {"Abc", "def", "ghi"};
```

两个声明之间的区别在于数组的第二维的大小——在第一个语句中是 4，在第二个语句中是 3。 第一条语句（声明 _strs_ ）包含空终止符的空间，这是使字符序列成为有效字符串所必需的。 第二个声明 _chrs_ 的语句不包括这样的空间，只存储写入的字符（没有空终止符）。

![](attachments/Pasted%20image%2020221014172507.png)

如果声明一个 _char_ 的多维数组来保存不同长度的字符串，那么你必须根据最长字符串的长度来调整第二维的大小

```c
char words[4][10] = {"A", "cat", "likes", "sleeping."};
```

![](attachments/Pasted%20image%2020221014172547.png)

这样可能会浪费空间.

可以改为对字符串数组使用指针数组表示

```c
const char * words[] = {"A", "cat", "likes", "sleeping."};
```

以 NULL 指针结束字符串数组是很常见的 允许编写循环遍历数组，而无需 _先验地_ 知道数组中有多少元素。

```c
const char * words2[] = {"A", "cat", "likes", "sleeping.", NULL};

const char ** ptr = words2;
while (*ptr != NULL) {
	printf("%s ", *ptr);
	ptr++;
}
printf("\n");
```

