---
date created: 2022-10-14 20:31
date updated: 2022-10-15 09:48
---

程序执行的实际指令（当然）是数字，它们存储在计算机的内存中，就像程序的数据一样。 因此，每条指令都有一个地址，就像每条数据一样。 由于这些指令有地址，我们可以有指向它们的指针。 拥有指向任意指令的指针通常没有用，但拥有指向函数中第一条指令的指针可能非常有用——我们通常将其视为指向函数本身的指针，然后调用 _函数指针。_

从技术上讲，任何函数的名称都是指向该函数的指针（即 _printf_ 是指向 printf 函数的指针），但是，我们通常不会这样认为它们。 相反，当我们提到函数指针时，我们通常指的是指向函数的变量或参数。 然而，函数名是指向它的指针这一事实对于初始化这些变量和/或参数很有用。

![](attachments/Pasted%20image%2020221014202111.png)

上图中非常相似的四段代码。 这些函数中 _s）的每个元素执行某些_ 的每一个都对数组（ **int** 操作——它们之间的唯一区别是 _它们_ 对每个元素执行的操作。

与其重复代码（每次都重写整个函数），不如编写一个函数，该函数接受一个参数来指定“对每个项目做什么”。 然后，我们可以简单地使用每个任务的适当函数调用该函数。 虽然避免这种代码重复在这里似乎并不那么重要（函数只有几行长），但当您编写更复杂的函数来操作更复杂的数据结构时，这种担忧可能会变得更加重要。

```c
void doToAll(int * data, int n, int (*f)(int)) {
	for (int i = 0; i < n; i++) {
		data[i] = f(data[i]);
	}
}
```

`int (*f) (int)`，它声明了一个参数（称为 f），它的类型是“一个指向函数的指针，它接受一个int 作为参数，并返回一个 _int_ 。” 函数指针声明有点不寻常，因为参数（或变量——声明具有相同的语法）的名称位于声明的中间。 然而，这种语法是有意义的，因为它看起来很像函数的正常声明——首先是返回类型，然后是名称，然后是括号中的参数。 然而，在这里，我们只需要指定参数类型； 我们没有命名它们。 请注意， _*f_ 周围的括号很重要——没有它们， _*_ 将成为返回类型的一部分（即， _*_ 被读取为 **int*** 的一部分），并且声明似乎描述了一个返回 **int*** 的函数。 有时 **括号** 和 _*_ 都可以省略（写 `int f (int)` )，但是，通常最好保持一致（并避免试图记住何时允许这样做；我们会提到它以防您看到它）。

可以将 **typedef** 与函数指针一起使用 语法类似于函数声明而不是其他形式的 **typedef**

```c
typedef int (*int_function_t) (int);
void doToAll(int * data, int n, int_function_t f) {
	for (int i = 0; i < n; i++) {
		data[i] = f(data[i]);
	}
}
```

```c
int inc(int x) {
	return x + 1;
}
int square(int x) {
	return x * x;
}
…
doToAll(array1, n1, inc);
…
doToAll(array2, n2, square);
…
```

函数名本身会被编译器解释成指针

可能会看到使用 address-of 运算符编写的此类内容，例如  `doToAll(array1, n1, &inc)` 。 这种语法是合法的，但是 _&_ 是多余的，就像数组名一样——函数名已经是一个指针。 请注意，如果我们有一个函数指针而不是函数的名称（ _即_ 是一个变量或参数），那么我们可以获取该变量的地址，从而为我们提供一个指向函数指针的指针。 在后一种情况下最好只使用地址运算符，这种情况很少出现。

## 排序函数

使用函数指针作为参数的另一个例子是通用排序函数 它可以对任何类型的数据进行排序

对数组进行排序是将该数组的元素按递增（或递减）顺序排列的过程。 对数组进行排序是程序中的一项常见任务，因为排序后的数据可以比未排序的数据更有效地访问。

有许多不同的排序算法，但它们都不关心数据的具体类型，只关心一条数据是“小于”、“等于”还是“大于”比”另一条数据。

创建一个通用的排序函数——一个可以对任何类型数据的数组进行排序的函数——通过让它接受一个参数，该参数是一个指向比较数组的两个元素的函数的指针。 事实上，C 库提供了这样一个函数（按升序排序——从小到大）：

```c
void qsort(void *base, size_t nmemb, size_t size,
			int (*compar)(const void *, const void *));
```

此函数的第一个参数 `void * base` 是要排序的数组。 回想一下 `void *` 是“指向未指定数据类型的指针”——允许 qsort 获取任何类型的数组。 第二个参数 `size_t nmemb` 指定数组中元素（或 _成员_ ）的数量（回想一下 _size_t_ 是适合用于事物大小的无符号整数类型）。 第三个参数 _size_t size_ 指定数组中每个元素的大小——即每个元素在内存中占用的字节数。 此信息是必需的，因为否则 _qsort_ 无法判断数组的一个元素在哪里结束，而下一个元素从哪里开始。 最后一个参数是我们在本次讨论中最感兴趣的参数 _compar_ 是一个指向函数的指针，该函数接受两个 `const void *s` 并返回一个 **int** 。 这里， `const void *s` 指向要比较的两个元素（它们是 **const** ，因为比较函数不应该修改数组）。 如果第一个指针指向的值大于第二个指针指向的值，该函数返回一个正数，如果它们指向相同的值，则返回 0，小于一个负数。

```c
int compareInts(const void * n1vp, const void * n2vp) {
	const int * n1ptr = n1vp; // convert back to int* so we can dereference
	const int * n2ptr = n2vp;
	return *n1ptr - *n2ptr; // subtracting the two numbers compares them
}
void sortIntArray(int * array, size_t nelements) {
	qsort(array, nelements, sizeof(int), compareInts);
}
```

编写一个比较函数 _compareInts_ 的接口兼容 ，它的行为与qsort_ ——它接受声明为 `const void *s` 的指针，并返回一个 **int** 。 由于此函数仅在对 **int** s 数组进行排序时使用，因此它将 `const void *s` 转换为 `const int *s`，并取消引用它们以获取数组中的实际 **int** s。 减去这两个 **int** 得到的结果符合 _qsort_ 函数的预期（如果第一个更大，则为正，如果相等，则为 0，如果第一个小于，则为负）。

_qsort_ 函数将调用 _compareInts_ 来确定数组中元素的相对顺序。

#important 

类似的函数来对字符串数组（一个 `const char *s` 数组）进行排序：

```c
int compareStrings(const void * s1vp, const void * s2vp) {
	// first const: s1vp actually points at (const char *)
	// second const: cannot change *s1vp (is a const void *)
	const char * const * s1ptr = s1vp;
	const char * const * s2ptr = s2vp;
	return strcmp(*s1ptr, *s2ptr);
}
void sortStringArray(const char ** array, size_t nelements) {
	qsort(array, nelements, sizeof(const char *), compareStrings);
}
```

`const void * s1vp` 决定了 **s1vp** 指向的内容是只读的
而在该例子中 , s1vp 指的内容是一个 **指针**. 该内容的指针指向一个字符串字面量.
因此需要声明一个 **指向 (指向字符串字面量的指针) 的指针** , 而且这个指针是只读的(由 `const void *` 决定)
`const char * const * s1ptr = s1vp;` **该类型指 s1ptr 是个只读指针 指向的内容是个 指针(指向一个字符串字面量)**
`const char * const * ==>  const char * *const`
`const *` 和 `* const` 沒任何區別，`char const*` 跟`const char *`也沒區別

请注意，传入的指针是指向数组中元素的指针（即它们指向数组中的框），即使这些元素本身就是指针（因为它们是字符串）, 也需要将其类型转换为指针类型。 当我们从 `const void *s` 转换它们时，我们必须注意将它们转换为正确的类型——这里是 `const char * const *` ——并适当地使用它们，否则我们的函数会以某种方式被破坏。 例如，考虑以下损坏的代码：

```c
// BROKEN DO NOT DO THIS!
int compareStrings(const void * s1vp, const void * s2vp) {
	const char * s1 = s1vp;
	const char * s2 = s2vp;
	return strcmp(s1, s2);
}
```

**这段代码实际上编译时不会出现任何错误或警告，但无法正常工作(即不会报错,但是实际上没有对数组进行排序)。 这是因为它比较的内容是把两个地址当作字符串来比较了, 而数组在内存中是连续的, 因此它不会改变顺序.**
每当你使用 `void *` 时，这都是一种危险——灵活性给了你“足够的绳索来吊死自己”，因为你不能保证你会以正确的方式使用指针。 正如我们稍后将看到的，C++ 在其类型系统中具有允许我们以更安全的方式拥有泛型函数的特性。

我们几乎可以在可以使用任何其他类型的任何地方使用函数指针——不仅作为参数的类型，还作为变量的类型、数组中元素的类型或 **struct** 中的字段。

**事实上，结构中的函数指针是面向对象编程的核心，尽管面向对象的语言对普通程序员隐藏了这个实现细节。**
