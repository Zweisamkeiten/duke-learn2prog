---
date created: 2022-10-14 13:38
date updated: 2022-10-14 14:59
---

## 字符串字面量

`const char *`, 字符串字面量 指向不能修改的字符指针

![](attachments/Pasted%20image%2020221014133838.png)

字符按字符串的顺序出现，后跟空终止符 **'\0'**

字符串只是内存中的一个字节序列（8 位数字），其中最后一个字节的数值为 0

使用 **const** 表示我们不能修改 _str_ 指向的字符（即，赋值给 _str[i]_ 将导致编译器错误）忘记添加 **const** 会收到此类警告,但代码仍能编译, (可以使用 `-Wwrite-strings`, 默认情况下 `-Wall`不会启用该错误 ) 省略 **const** 并尝试修改字符串，程序将因 _分段错误_ 而崩溃。

该崩溃产生的原因是尝试修改一个字符串字面量, 而字符串字面量的数据储存在静态数据节(_static data section_) 的 _read only portion_ 只读部分.
![](attachments/Pasted%20image%2020221014135459.png)
字符串文字通常放置在静态数据部分的只读部分中

字符串字面量的数据（构成字符串的实际字节）在程序的整个生命周期内（从加载到内存到退出）都驻留在静态数据部分的只读部分中。 该数据由 _加载程序_  放入内存——操作系统的一部分，它从磁盘读取可执行文件并适当地初始化其内存。 加载器知道要为字符串文字写什么（以及它们应该在内存中的什么位置），因为编译器会将信息写入描述数据部分内容的可执行文件中。 加载程序完成内存初始化后，它会将静态数据部分的只读部分标记为 _页表_ (操作系统维护该结构以向硬件描述程序的内存)中的不可写。

尝试向只读部分的内存写将会像向一个内存非法区域写入一样, 它会导致硬件 _trap_ 陷入操作系统(将执行控制权从运行的程序转向操作系统内核), (从概念上讲, 硬件将执行箭头从我们的程序中取出,并将其放入操作系统中的特定函数中,注意执行箭头的位置,以防止操作系统想要将控制权返回给我们的程序). 操作系统看到程序试图以无效的方式访问内存,并以分段错误将其杀死.

编译器将字符串文字放入内存的只读区域，因为文字可能会被重用，因此不应去更改。

```c
char * str1 = "Hello";
str1[0] = 'J'; // this would crash, but suppose it did not
…
…
char * str2 = "Hello";
printf("%s\n", str2);
```

两次出现的文字“Hello”都计算为指向存储该字符串字符的位置的指针。 编译器可以自由地将两个相同的字符串文字放在一个位置，这意味着 _str1_ 和 _str2_ 可以指向同一个内存。 如果允许修改此内存，打印 _str2_ 将打印“ _Jello_ ”

即使文字只出现在程序中的一个地方，它也可能会被重复使用多次（在循环内、在被多次调用的函数中等 ）

## 可变的字符串

当我们想要修改一个字符串, 需要将字符串存在可写内存中, 例如一个函数的栈帧, 或者使用 `malloc` 动态分配内存.

```c
char str[] = "Hello World\n";
char str[] = {'H', 'e', 'l', 'l', 'o', ' ',
			  'W', 'o', 'r', 'l' 'd', '\n', '\0'};
```

将 **str** 声明为 `const char * str` 与 `char str[]` 之间的区别

![](attachments/Pasted%20image%2020221014141149.png)

使用数组方法声明特定长度字符串时, 如果没有足够的空间为`\0` 空终止符, 编译器不会警告报错, 相反，它将完全按照我们的要求初始化字符数组，但不会在末尾放置 '\0'。 编译器允许这种行为，因为它生成了一个完全有效的字符数组，即使它不是一个有效的 _字符串_ 。 (`char str[12]="Hello World\n";`) 如果我们只以只访问这 12 个字符的方式对数组进行计算，那么我们的程序就可以了。 但是，如果我们将该数组用于任何的东西（例如，将其传递给 _printf_ 或任何您将很快了解的字符串库函数 _需要实际字符串_（即末尾带有空终止符)），那么数组将被访问超出其边界。

请求 _更多_ 比字符串所需 的空间是完全可以的。 例如， `char str[100] = "Hello World\n";` 是完全合法的。

重要: 程序员有责任去追踪所有创建的数组的大小. 因为没有办法去检查一个数组,并得出其大小.

## 字符串相等

比较两个字符串以查看它们是否相等

如果写 _str1 == str2_ ，它将检查 _str1_ 和 _str2_ 的箭头 **是否是指向同一个地方**

有时指针相等是我们的意思，但更多时候，我们想检查两个字符串是否具有相同的字符序列，即使它们位于内存中的不同位置。

![](attachments/Pasted%20image%2020221014141953.png)

函数 `strcmp` C 库的 `string.h` 中

C 库 _strcmp_ 函数的行为如果字符串相等，则返回 0，如果不同，则返回非零。

如果第一个字符串“大于”第二个字符串，则返回正数；如果第一个字符串“小于”第二个字符串，则返回负数。 这里的“大于”和“小于”指的是 _字典顺序_ ——你会认为是“字母顺序”，但扩展到包含字符串可能有非字母的事实。 比较区分大小写（因此 _abc_ 与 _Abc_ 不同），但还有另一个函数 _strcasecmp_ 执行不区分大小写的比较。

## 字符串复制

![](attachments/Pasted%20image%2020221014144311.png)

![](attachments/Pasted%20image%2020221014144318.png)

_strncpy_ 将字符串从一个位置复制到另一个位置. 并接受一个参数 ( _n_ ) 告诉它允许复制的最大字符数。 如果源字符串的长度大于或等于 _n_ ，则目标将 _不是_ 以空值结尾的——程序员通常必须在将字符串用于任何重要目的之前纠正这种情况。

_strcpy_ （前一个在其名称中间有一个 **n** ，而这个没有）。 函数更危险，因为 _strcpy_ 无法告诉它目标中有多少可用空间。 如果可用空间不足，则 _strcpy_ 将简单地覆盖内存中紧随其后的任何内容，从而产生各种问题。

_strdup_ 为字符串的副本分配空间，并将其复制到该空间中。

## 将字符串转换为整数

字符串不能通过强制转换隐式转换为整数（或浮点类型）——无论是隐式的还是显式的

```c
int x = str;
// 编译错误: initialization makes integer from pointer without a cast
```

出现此错误是因为赋值不会 _将_ 字符串以文本形式表示的数字转换为整数（它不会导致 _x=12345_ ）。 相反，它将取 _str_ 的数值（它是一个指针，因此它的数值是存储字符序列 12345 的内存中的地址）并将其分配给 x。 这种行为完全遵循我们在赋值语句中学到的规则：将右侧评估为一个值（这是一个箭头，意味着它的数值是一个地址），并将其写入左侧命名的框中。

![](attachments/Pasted%20image%2020221014145538.png)

变量 _str_ （其字节以红色着色）是一个指针，在此特定系统上为 8 字节。 它的数值是字符串文字“ _12345_ ”的字节在内存中的地址，即0x100000f40。 内存位置 0x100000f40–0x100000f45 的内容是该字符串的字符——字符“1”（0x31）、“2”（0x32）、“3”（0x33）、“4”（0x34）、“ 5' (0x35) 和 _'\0'_ (0x00) 的顺序。 变量 _x_ 是一个 _int_ 占用 4 个字节，其中保存值 0x00003039，即十进制的 12345。

_x_ 不能保存整个值（请记住，在这个特定的系统上，指针是 8 个字节，但 int 是 4 个字节），该值将被截断。 _x_ 最终会被赋值为 0x0000f40（0x100000f40 的最低四个字节），即十进制的 3904

想获得输入的数字 "12345" 将其转换为 12345
```c
printf("Please enter a number:");
char * str = readAStringFromTheUser(); //we'll learn how later
int x = str; // they will enter a string.
// we'd like to store it as an int..
```

如果我们想自己手动执行这样的转换，我们需要遍历字符串中的字符并执行数学运算。

_atoi_ 最简单的——它通过将字符序列解释为十进制数来将字符串转换为整数。 如果开头没有有效数字，则返回 0。 

稍微复杂一点的函数是 _strtol_ ，它允许您指定基数（十进制、十六进制等），以及传入 `char *` 的 地址它将用指向数字后第一个字符的指针填充。 也就是说，如果你给它一个字符串 _123xyz_ ，它会设置这个指针指向' _x'_ （你也可以传入 NULL，如果你不需要这个额外的信息，在这种情况下它会跳过这部分）。 这个额外的参数允许您进行错误检查，和/或找出数字后面的内容（如果它是您需要处理的较大输入的一部分，例如逗号分隔的数字列表）。