---
date created: 2022-10-13 16:12
date updated: 2022-10-13 16:19
---

## 别名

![](attachments/Pasted%20image%2020221013160846.png)
对同一个框有多个名称.

当我们调试（或手动执行代码）时，理解别名也很重要。 新手 C 程序员经常对变量更改其值而不被直接赋值的事实表示惊讶和困惑：“我写了 _x = 4_ ;，然后看我没有在这段代码的任何地方赋值给 _x_ ，但现在它是 47 ！” 通常，这种行为表明您为有问题的变量设置了别名; 在 _gdb_ 使用 `watch` 命令

![](attachments/Pasted%20image%2020221013161100.png)

![](attachments/Pasted%20image%2020221013161234.png)

将得到 1078523331！当将浮点数转换为整数时（在第二段代码中），我们要求编译器插入从浮点数转换为整数的指令。

但是当解引用指向 int 的指针时，编译器只会生成指令来读取内存中该位置的位模式，因为它已经是 int。 在第一段代码中，初始化 **float** _f = 3.14_ ； 浮点编码的位模式将 _3.14_ 写入 名为 _f_ 的盒子。 浮点编码计算， _3.14_ 为 _0100 0000 0100 1000 1111 0101 1100 0011_（=十六进制的 _0x4048F5C3_ ，十进制的 1078523331）。 当我们将指针取消引用为 int 时，程序会读取该位模式，将其解释为整数，并打印 _1078523331_ 作为输出，如上图所示。

最后一个例子不是你需要在你编写的程序中使用的东西，而是对滥用指针的警告。 除非/直到您确切了解这里发生的事情并且有充分的理由这样做，否则您不应该在指针类型之间进行转换。

## 指针算术

```c
int x = 4;
float y = 4.0;
int *ptr = &x;
x = x + 1;
y = y + 1;
ptr = ptr + 1;
```

对于整数指针ptr（最初指向x), 加 1 的语义是“内存中的一个整数”。递增指针应该让它指向内存中的“下一个”整数。为了做到这一点，编译器发出指令，实际上是添加字节数一个整数在内存中所占的比例（ _例如_ ，+1 表示将指针的数值更改+4)。

这就是为什么指针算术不适用于指向 void 的指针。 由于编译器不知道一个“东西”有多大，它不知道如何计算移动 N 个“东西”。

递增指针会将其指向内存中的 _某个_ 位置，我们只是不知道是什么。 它 _可以_ 是 y 的框、函数的返回地址，甚至是 ptr 本身的框。

简单地对不指向有效框的指针执行算术运算本身并不是错误——问题只是在我们不知道指针指向什么的情况下取消引用。

通常不会做这些事情，您应该知道什么是可接受的编码实践和不可接受的编码实践之间的区别。

## 使用内存检查工具


使用内存检查工具至关重要，例如 **valgrind** 和/或编译器选项 **-fsanitize=address** 。 这些将帮助您发现错误行为，并使修复程序更容易。 在整个测试过程中使用它们。[编译器选项](../../01_writing_running_and_fixing_code_in_C/Week2/编译器选项.md#^6634a0)