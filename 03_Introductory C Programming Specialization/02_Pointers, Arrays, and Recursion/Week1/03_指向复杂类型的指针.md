---
date created: 2022-10-13 13:39
date updated: 2022-10-13 14:16
---

## 指向结构体的指针

![](attachments/Pasted%20image%2020221013133855.png)
结构体指针用法
`(*q).x` 或者 `q ->  x`

因为 `.` 运算符的优先级高于 `*` 因此需要加上括号

`(*(*(*q).r).s).t` == `q-> r-> s-> t`

` ->  ` 箭头运算符是解引用指针并选择字段.

## 指向指针的指针

`int **` 是一个 指向一个 `int` 的指针 的指针.

![](attachments/Pasted%20image%2020221013135652.png)

a pointer gives us the ability to refer to the location of a thing, rather than to have a copy of that thing. 指针给予我们引用一个地址代表的内容的能力, 而不是为该内容创建一个备份.

Note that * and _&_ are inverse operations—if we write `*&e` or `&*e`, they both just result in e (whenever they are legal).

## Const 常量

```c
const int x = 3;
```

`const` 标识符告诉编译器该变量将不再允许被修改.

```c
const int * p = &x;
```

与第一个常量例子不同
声明 `p` 指针指向一个常量int.
可以改变 p 的指向, 例如可以使 p 重新指向 (p = &y; 合法). 修改 p 指向的值是不合法的 (`*p = 4;` 不合法)
p指向的东西才是常量.

```c
*p = 4; // assignment of read-only location '*p'
```

两种写法

```c
const int *p = &x;
// ==
int const * p = &x;
```

如果我们想指定 可以修改 `*p` (p 指向的内容), 而不能修改 `p` 本身. 可以这样写 `int * const p = &x;`. _p_ 是一个 **const** 常量指针指向一个可以修改的 **int**. 这样 `*p = 4;` (合法), `p=&y;` (不合法)

```c
const int * const p = &x; // 既不能修改 p指向的内容, 也不能修改 p本身
```

![](attachments/Pasted%20image%2020221013141540.png)

请注意，**只有当我们尝试通过声明为 const 的变量更改数据或执行删除 const 的操作时，const 的声明才会告诉编译器给我们一个错误。** 例如，以下是合法的：

```c
int x = 3;

const int * p = &x;

x = 4;
```

在这里，我们不允许更改 `*p`，但是，我们在 `*p` 处找到的值仍然可以通过分配给 x 来更改（因为 x 不是 const，所以分配给它不是错误）。 但是，如果我们写：

```c
const int y = 3;

int * q = &y;

*q = 4;
```

会产生错误警告

```
initialization discards 'const' qualifier(限定词) from pointer target type [enabled by default]
```

错误发生在第二行. 为类型为 `int *` 的 q 赋予 类型为 `const int *` 的值, 而导致丢失了 const 限定词.