---
date created: 2022-10-13 12:06
date updated: 2022-10-13 13:34
---

![](attachments/Pasted%20image%2020221013115848.png)

硬件为内存的每一个位置都赋予一个数字地址.

指针存储了它们所指向的变量的地址。 变量 _y_ 是一个初始化为指向 x 的整数指针。 概念图将其显示为指向标有 _x 的框的箭头。_ 硬件图将其显示为一个值为 _104_ 的基地址 _的变量，即x_ 。 变量 z 被声明为指向 _char_ 的指针。 虽然一个字符只有 1 个字节，但地址是 32 位，因此 _z_ 的大小为 4 个字节，并且包含值 _101_ ，即 c3 的位置。 (如果这些变量位于具有更高地址的内存位置，则地址的数值会更大，所有四个字节都会有非零值. 包括指针 _y_ 和 _z_ 。）

指针是其值为地址的变量。 指针只能指向 _可寻址_ 数据。 不能指向与内存中的某个位置不对应的表达式，因此程序不能尝试对这些表达式使用取地址运算符。 例如， _3_ 和 ( _x+y_ ) 都不是表示内存中可寻址“盒子”的表达式。 因此，像这样的行是非法的： _int *ptr = &3_ ; 和 int _*ptr = &(x + y_ );。 注意 _3_ 和 ( _x+y_ ) 不是左值——它们不是命名盒子，这就是它们不能有地址的原因。

该规则的推论是赋值语句只能分配与内存中的位置相对应的变量。 所以表达式如 _3 = 4;_ 或 _x+y+z = 2_ 也会触发编译器错误。

## 程序的内存视图

在 32 位机器上，地址大小为 32 位，整个内存空间从 0x00000000（十六进制中，每个 0 表示 0 的 4 位）开始，到 0xFFFFFFFF 结束（回想一下，0x 表示十六进制，每个 F 表示四个二进制 1）。 每个程序都有这整个地址空间可供使用，并且对于程序如何使用这个地址范围有一个约定。

![](attachments/Pasted%20image%2020221013131054.png)

### Code

将C 等语言编写程序转换为计算机可读的一堆数字（称为目标代码）。 例如，C 语言中将两个数字相加的指令可能被编码为目标代码中的 32 位指令。 32 位中的一些将告诉机器执行加法，一些位将编码要添加的两个数字，还有一些位将告诉处理器它应该将计算的和存储在哪里。 编译器将 C 代码转换为目标代码，并为每条编码指令分配一个内存位置。 这些编码的程序指令存在于内存的代码部分，在上图中以黄色显示。

### 静态数据

静态数据区包含可在整个程序运行期间访问的变量（ _例如_ 全局变量）。 与在函数内部声明并且在函数返回时不再可访问的变量不同，静态变量在整个程序终止之前都可以访问（因此，术语 _static_ ）。

### 堆和栈

内存的最后两个部分用于在程序执行期间的特定时间可用的两种不同类型的程序数据。 。 **堆** （紫色）存储动态分配的数据 。 **栈** （橙色）存储每个函数声明的局部变量 栈被划分为 _栈帧_ ，这些栈帧从调用函数时开始可用，一直持续到函数返回。 贯穿本书的概念图主要将帧的图片显示为带有局部变量的框（每个函数一个）。 实际上，栈是一块连续的内存。 每个栈帧都位于调用它的函数的栈帧下方。

_调用约定_ ——参数传递和函数返回值的具体细节类似于 x86 机器 函数的参数驻留在调用它的函数的栈框架中。 这与我们之前展示的概念图略有不同，其中参数放置在被调用函数的栈框架中。 对于概念图，这既足够又易于理解。 每个目标架构的硬件细节都会略有不同。

![](attachments/Pasted%20image%2020221013132802.png)

## NULL

![](attachments/Pasted%20image%2020221013132851.png)
代码段下方有一个空白区域，是程序内存的无效区域。程序使用数值为 0 的指针——它有一个特殊的名称，NULL 表示“不指向任何东西”。 通过没有将程序的任何有效部分放置在（或靠近）地址 0，我们可以确定不会在地址 0 放置任何内容。这意味着实际上指向某物的正确初始化的指针永远不会具有 NULL 值。

1. 返回“没有答案”——使用指针
2. 无法分配内存
3. 函数中的一些行为, 打开文件等 创建失败

使用NULL时，将它表示为一个平头的箭头（表示它不指向任何东西）

![](attachments/Pasted%20image%2020221013133047.png)

如果我们试图跟随箭头（ _即_ ，解引用），那么我们的程序将因 _分段错误_ 而崩溃——该错误表明我们试图以无效的方式访问内存（事实上，如果程序试图访问任何区域上图中“空白”的内存，它将因分段错误而崩溃）。

Null 指针还有一种特殊的类型 `void *`  . 它可以指向任何类型, 可以将 `int *` , `double *` 类型的指针赋给它. 不知道 void * 实际指向什么, 也无法解引用它.(因为编译器不知道其指向的类型). 也无法进行指针运算.
