---
date created: 2022-10-13 17:38
date updated: 2022-10-14 20:40
---

## 数组声明和初始化

创建一个数组时，指定它的大小（ _即_ 序列中的项目数）

`int myArray[4];`

变量名（在本例中为 _myArray_ ）是 _指向_  4 个框组成数组的指针。 与其他变量不同，myArray 不是左值——不能改变它指向的位置。 相反，它只是命名一个指向数组中第一个框的指针。 从 C99（1999 年定义的 C 的“版本”）开始，可以使用非常量表达式作为大小来声明数组，即我们可以写 **int** _myArray[x]_ ;，其中 _x_ 是先前声明的（并已初始化） !) 整数变量。 您通常希望为 _gcc_ 提供命令行选项 _--std=gnu99_ ，以启用 C99 中定义的功能——这就是这样的功能之一。

![](attachments/Pasted%20image%2020221013173940.png)
有 4 个框（尚未初始化），并且 _myArray_ 没有框 - 它只是指向第一个框的箭头的名称。

> 问：我们已经看到C语言中数组和指针之间的紧密联系。称它们是可互换的是否准确？
> 答：不准确。数组型形式参数和指针形式参数是可以互换的，但是数组型变量不同于指针变量。从技术
> 上说，数组的名字不是指针，C语言编译器会在需要时把数组的名字转换为指针。为了更清楚地看出
> 两者的区别，思考对数组a使用sizeof运算符时会发生什么。sizeof(a)的值是数组中字节的总数，
> 即每个元素的大小乘以元素的数量。但是，如果p是指针变量，那么sizeof(p)的值则是用来存储指
> 针值所需的字节数量。

绘制 _myArray_ 时没有自己的框，以强调 _myArray_ 不是左值这一事实——我们无法更改它

可以在声明它的同一行中初始化一个数组

```c
int myArray[4] = {42, 39, 16, 7};
```

初始化程序中写入太多元素，会收到警告. 如果写的元素太少，编译器会默默地用 0 填充剩余的元素。这种行为对于对整个数组进行零初始化来说是一个有用的特性——我们可以在花括号中只写一个 0，编译器将填充与数组元素一样多的零：

```c
int myArray[4] = {0}; // initialize all elements to
```

类似于结构体的初始化

```c
point p = {3, 4}; //这种形式的初始化是非常脆弱的——如果你在这两者之前或之间向结构体添加另一个字段，你将不再按照你想要的方式初始化这些字段
point p = { .x = 3, .y = 4}; //如果将另一个字段添加到结构中，它将被零初始化，并且 _x_ 和 _y_ 字段仍将正确初始化。
```

```c
point myPoints[] = { {.x = 3, .y = 4},
					 {.x = 5, .y = 7},
					 {.x = 9, .y = 2} };
```

## 访问数组

越界访问数组（在任何不存在的元素处）是编译器无法检测到的错误。

事实上，指针运算和数组索引在底层是完全相同的，编译器将 `myArray[i]` 转换为 `*(myArray + i)`

```c
myArray[i]
*(myArray + i)
i[myArray] = *(i + myArray) // 加法是可交换的
```

这个琐事完全没有用, 除了在聚会上让你的朋友惊艳，并与懂一点 C却不知道上述事实的人打赌之外。

取 &myArray[i]，它等价于 _&*_ ( _myArray +i_ )，而 _&_ 和 _*_ 取消（正如我们之前所学，它们是逆运算符），所以它是只是 _myArray + i_

这个结果是幸运的，因为它与我们希望的结果一致： `&myArray[i]` 说“给我一个指向myArray第 _i_ 个框的指针，而 `myArray + i` 说“给我一个指针在 _myArray_ 指向的位置之后第 _i_ 个框 ——这是描述同一事物的两种不同方式。
