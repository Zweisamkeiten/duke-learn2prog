---
date created: 2022-10-19 21:58
date updated: 2022-10-19 22:15
---

## 动态分配问题

#valgrind #debug
Valgrind 的 Memcheck 工具对于查找与动态分配相关的问题非常有用——无论 **是 C 中的malloc** 和 **free** ，或者，如果您继续学习 C++， **new** / **new[]** 和 **delete** / **delete[]** 。 与其他内存区域一样，Memcheck 将明确跟踪哪些地址有效，哪些地址无效。 它还准确跟踪 **malloc** 、 **new** 和 **new[]** 返回的指针，并在分配块的每一侧放置一些无效空间。

从所有这些信息中，Memcheck 可以报告各种各样的问题。 首先，如果访问刚刚超过动态分配数组的末尾，Memcheck 可以检测到这个问题。 其次，Memcheck 可以检测双重释放指针、释放不正确的指针以及分配和解除分配之间的不匹配（ _例如，_ **delete** 分配的 使用 **malloc** 内存，或者将 **delete[]** 与 **delete** 混合，这对于 C++ 程序员来说是一个错误）。 例如，假设我们编写了以下（显然是错误的）代码：

```c
int * ptr = malloc(sizeof(int));
ptr[1] = 3;
```

如果我们在 Memcheck 内部运行它，它会报告以下错误：

```
==5465== Invalid write of size 4
==5465==    at 0x40054B: main (outOfBounds.c:8)
==5465==  Address 0x51fc044 is 0 bytes after a block of size 4 alloc'd
==5465==    at 0x4C2AB80: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==5465==    by 0x40053E: main (outOfBounds.c:7)
```

错误首先告诉我们问题（我们进行了 4 个字节的无效写入），堆栈跟踪指示无效写入发生的位置（在 main 中，在文件 outOfBounds.c 的第 8 行）。 第二部分告诉我们程序试图访问的无效地址和最近的有效位置。 在这种情况下，它会将其报告为“0 字节之后”（意味着在经过有效区域的第一个无效字节中）“大小为 4 的块”（意味着将多少空间分配到该有效区域）。 Memcheck 然后报告该有效内存区域的分配位置（在第 7 行的 main 中，通过调用 malloc）。

请注意，如果我们最近释放了一块内存，Memcheck 将报告与该内存块的接近程度，即使它不再有效。 例如，如果我们写：

```c
int * ptr = malloc(sizeof(int));
free(ptr);
ptr[0] = 3;
```

然后 Memcheck 将报告无效写入位于已释放块内（并告诉我们释放块的位置）：

```
==5486== Invalid write of size 4
==5486==    at 0x4005A3: main (outOfBounds2.c:9)
==5486==  Address 0x51fc040 is 0 bytes inside a block of size 4 free'd
==5486==    at 0x4C2BDEC: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==5486==    by 0x40059E: main (outOfBounds2.c:8)
```

Valgrind 的 Memcheck 也会检查内存泄漏。 但是，默认情况下，它只报告泄漏的摘要，这对于查找和修复问题没有用处。 如果您有内存泄漏，您将需要使用 **--leak-check=full** 选项运行。 当您这样做时，Memcheck 将报告每个未释放的分配的位置。 然后，您可以使用此信息来确定应该在哪里释放该内存。

请注意，当使用 GDB 运行 Valgrind 的 Memcheck 时，您可以随时使用监控命令 **monitor leak_check full reachable any** _运行泄漏检查器。_

![monitor leak_check full reachable any](attachments/Pasted%20image%2020221021141739.png)
![通过gdb联调来找到还未释放的内存](attachments/Pasted%20image%2020221021142026.png)