## 无效的读取和写入
Valgrind 的 Memcheck 工具还会对内存访问（ _例如_ ，通过指针）执行比您运行程序时更严格的检查。 特别是，Memcheck 将跟踪每个地址在任何特定时间是否有效（以及该地址是否包含初始化数据）。 任何对无效地址的访问都会导致 Memcheck 出错。

例如，假设我们编写了以下（损坏的）代码：
```c
//horribly broken--returns a dangling pointer!
int * makeArray(size_t sz) {
	int data[sz];
	for (size_t i = 0; i < sz; i++) {
		data[i] = i;
	}
	return data;
}
```
该函数返回悬空指针. 代码可能不会报错, 但如果继续使用该悬空指针, 可能会带来意想不到的错误. 如果我们在 Valgrind 中运行这样的代码，我们可能会得到如下错误：
```
==24640== Invalid read of size 4
==24640==    at 0x40060C: main (dangling.c:16)
==24640==  Address 0xfff000340 is just below the stack ptr.
```
在这里，Memcheck 告诉我们，**我们试图从一个无效（当前未分配的）内存位置读取 4 个字节。 它为我们提供了无效读取发生位置的调用堆栈跟踪（在本例中，它位于代码的第 16 行）。** Memcheck 告诉我们哪个地址遇到了问题，并为我们提供了关于该地址相对于内存有效区域的位置的最多信息。 在这种特殊情况下，地址就在堆栈指针的下方，这意味着它位于最近返回的函数的框架中。 如果我们改为写入地址，我们会收到一条关于“大小为 X 的无效写入”的消息。

**请注意**，Memcheck 无法检测到所有与内存相关的错误（即使它可以检测到许多会漏掉的错误）。 如果调用了另一个函数（它将在同一地址范围内分配一个帧），内存将再次变为有效，并且 Memcheck 将无法判断通过该指针对其的访问是不正确的。 同样，Memcheck 可能无法检测到数组越界错误，因为未正确访问的内存位置可能仍然是程序访问的有效地址（ _例如_ ，某些其他变量的一部分）。

注意，使用 **-fsanitize=address** 可以发现很多 Memcheck 无法找到的这类问题。 原因是 **-fsanitize=address** 会在变量之间强制使用额外的未使用位置，并使用它使用的有效位将它们标记为不可读。 因为现在变量之间存在空间无效空间，所以 **-fsanitize=address** 插入的检查将检测它们之间的访问，例如超出一个数组的边界。 #important #newget #valgrind #debug 