## 未初始化的值

如果使用了一个未初始化的值, 当运行程序时，将得到一个值(它只是之前发生在那个内存位置的任何东西)，并且没有任何检查该值是否已初始化.

更改程序的输入可能会导致不同的执行路径导致使用未初始化的值，从而导致它以各种不同的可能方式具有不同的值。 另一种可能性是，如果您使用优化而不是调试来编译代码。 当编译器优化您的代码时，它可能会将不同的变量放在相对于调试版本的不同位置。 因此，这样的错误可能会导致令人讨厌的情况，即您的程序的调试版本似乎可以工作，但优化版本却不能（即使在相同的输入上）

Valgrind 的 Memcheck 工具显式跟踪程序中每一位的有效性，并可以告诉我们未初始化值的使用情况。 默认情况下，当您使用未初始化的值时，Memcheck 会告诉您； 但是，这些错误仅限于某些用途。 如果 **x** 未初始化，而您执行 **y = x** ，则 Memcheck 不会报告错误，而只是注意 **y** 现在拥有一个未初始化的值。 事实上，即使我们计算 **y = x + 3** ，我们仍然不会立即得到错误。

但是，如果我们以某些 Memcheck 认为会影响程序行为的方式使用未初始化的位置（或保存从未初始化的位置计算的值的位置），它将给我们一个错误。 一种这样的情况是程序的控制流依赖于未初始化的值——当它出现在 **if 语句、循环的条件表达式或** **switch** 语句的选择表达式中时。 在这种情况下，Memcheck 会产生错误：

`Conditional jump or move depends on uninitialized value(s)`
并生成一个调用堆栈跟踪，显示该使用发生的位置。 例如，如果我们编写函数：

```c
void f(int x) {
	int y;
	int z = x + y;
	printf("%d\n", z);
}
```

Valgrind 的 Memcheck 会报如下错误（这段代码在 uninit.c 里面， _在_ 上面显示的前后还有其他几行）：

```
==12241== Conditional jump or move depends on uninitialised value(s)
==12241==    at 0x4E8158E: vfprintf (vfprintf.c:1660)
==12241==    by 0x4E8B498: printf (printf.c:33)
==12241==    by 0x400556: f (uninit.c:7)
==12241==    by 0x400580: main (uninit.c:15)
```

此错误表明在 **vfprintf** 内部使用了未初始化的值，该值由 **printf** 调用，由 **f** 调用（在第 7 行），由 **main** 调用（在第 15 行）。 我们可以通过观察第 7 行对 **printf** 的调用并查看我们做错了什么来直接修复程序。

**但是，如果我们没有立即发现问题（如果未初始化的值在 Memcheck 报告错误之前已通过各种函数参数和数据结构传递），我们需要 Memcheck 提供更多帮助。** 事实上，当 Memcheck 报告此类错误时，它会在其输出的末尾提示我们需要从中获取更多信息的选项：`==12241== Use --track-origins=yes to see where uninitialised values come from`

如果我们再次运行 Valgrind 并传入此选项（ **valgrind --track-origins=yes ./myProgram** ），它将在报告错误时报告未初始化值的创建位置： #important #newget #valgrind #未初始化 #debug 

```
==12260== Conditional jump or move depends on uninitialised value(s)
==12260==    at 0x4E8158E: vfprintf (vfprintf.c:1660)
==12260==    by 0x4E8B498: printf (printf.c:33)
==12260==    by 0x400556: f (uninit.c:7)
==12260==    by 0x400580: main (uninit.c:15)
==12260==  Uninitialised value was created by a stack allocation
==12260==    at 0x40052D: f (uninit.c:4)
```

我们现在可以看到该值是由堆栈分配创建的（意味着为函数分配一个帧），并且我们有导致该创建的特定代码行（ **int y;** inside of **f** ）。

在其他情况下，使用未初始化的值将导致消息，例如：`==12235== Use of uninitialised value of size 8`
这里 Memcheck 告诉我们，我们以一种它认为有问题的方式使用了未初始化的值，并且我们使用的值是 8 字节大小（即它正在访问多少字节的内存）。 如果将我们未初始化的值传递给系统调用，我们将收到如下所示的错误消息：`==12362== Syscall param write(fd) contains uninitialised byte(s)`

所有这些都表明了相同的基本问题：我们有一个没有初始化的值。 我们需要找到它（可能通过使用 **--track-origins=yes** ）并正确初始化它。