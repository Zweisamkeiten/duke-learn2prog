---
date created: 2022-10-19 17:33
---

丢失了对内存块的所有引用（即没有指针指向它），并且内存仍然被分配时，已经 _泄漏了内存_(程序有 _内存泄漏_)

在最多运行几秒钟的小程序中，内存泄漏可能不会产生太大影响. 当程序退出时，分配给程序的所有内存都将被操作系统释放

在实际程序中，内存泄漏会带来严重的性能问题。 您是否发现某些程序打开时间越长越慢？ 也许您有一个程序，如果打开一两天，您必须重新启动，因为它非常缓慢。 一个很好的猜测是编写它的程序员马虎，而且它正在泄漏内存。

不能够成为一个草率的程序员, 需要释放程序所有的内存.

#important
当你编写一个程序时，你应该在 _valgrind_ 中运行它，并确保你在最后得到以下信息：

```
All heap blocks were freed -- no leaks are possible
```

## 动态内存分配类比

在公共汽车站，有 50 个储物柜可供出租。 要申请储物柜，您只需告诉窗口的工作人员您需要多少储物柜。 你会得到一个连续的储物柜，你会被告知哪个是你的第一个储物柜。 例如，您可能会说“请提供 5 个储物柜”，然后您可能会被告知“您的起始储物柜是 37 号”，此时您已获得 37 到 41 号储物柜。您也可能会被告知“不，抱歉。 " 因为没有 5 个连续的储物柜可供出租。 响应您的成功请求，窗口的工作人员记录了 5 个储物柜正在使用中，从 37 号储物柜开始。

当你用完你的储物柜后，你回到窗口告诉工作人员“我从 37 点开始用完储物柜”，这 5 个储物柜现在可供排在你后面的其他人使用。 当您归还储物柜时，**您可以释放全部或一个都不释放。 您不能返回请求的子集, 即只释放其中的一部分。** 用技术术语来说，您只能使用 malloc 返回的指针调用 free。 此外，您不能两次归还储物柜。 即使您和您的伴侣都在使用储物柜，也只有你们中的一个人应该归还它们。 同样，从技术角度讲，您只能调用一次 free，即使内存中有多个指向该位置的指针。 多次释放内存中的同一位置是非法的。

## 常见问题

尝试两次“释放”相同的储物柜是一个问题。 在内存分配的情况下，尝试多次释放同一块内存称为 _双重释放_ 。通常程序会因(段错误segfault)而崩溃. 只因为某特定行上发生的段错误是比较容易debug的. 但是, 当下次调用 _malloc_ 时, 程序有可能会崩溃. 当出现 malloc 崩溃问题时, 这是一个早期错误, 通过 _valgrind_ 能够及时发现.

另一个常见的问题，在更衣室的类比中也提到过，是释放一些不在 malloc 返回的块开头的东西。 如果储物柜服务员给了你 37-41 的储物柜，你不能回去说“我用完了 38”。

#newget #important 
他们需要自己记账，以跟踪内存的哪些部分是空闲的，哪些部分正在使用，以及每个正在使用的块有多大。 簿记需要内存：他们必须存储自己的数据结构来跟踪信息——**但是他们从哪里获得内存来跟踪正在使用的内存呢？ 答案是 malloc 实际上分配了比您要求的更多的内存，并且在它给您的开始之前为自己保留了一点。** 你可能要求 16 个字节， malloc 给你 32 个字节——前 16 个包含有关块的信息，接下来的 16 个包含它给你使用的信息。 当您释放块时，free 函数根据您给它的指针计算元数据的地址（ _例如_ ，减 16）。**因此如果你提供了一个指向块中间位置的指针，它会在错误的地方寻找元数据。**

储物柜的类比，这就像储物柜服务员给了你储物柜 37-41，但随后在储物柜 36 中放了一张纸条，上面写着“这块储物柜有 5 长”。 当您返回 37 号储物柜时，他会在 36 号储物柜中查看并找到纸条。 如果你尝试归还 38 号储物柜，他会在 37 号储物柜中查看并变得非常困惑。

第三个常见错误是释放不在堆上的内存。 如果您尝试释放 栈（或全局）上的变量，将会发生一些不好的事情——您的程序很可能会崩溃。