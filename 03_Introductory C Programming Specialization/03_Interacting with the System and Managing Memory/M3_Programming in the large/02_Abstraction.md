
## 抽象

设计任何大型系统的关键技术之一是 _抽象_ 。 
抽象是接口与实现的分离。 某事物的 _接口_ 是它是做什么的, 而 _实现_ 是它是怎样做到的.

例子：驾驶汽车而不是知道它在引擎盖下是如何工作的。 汽车提供了一个简单的界面（转动方向盘使汽车转动，踩油门使汽车行驶得更快，踩刹车使汽车减速……）。 然而，实现（一切如何在幕后工作）是相当复杂的

_知道函数是做什么_ 它，而不必知道 _它是怎么_ 做的

如果一个函数的复杂性超出了你的认知能力，那么编写它就变得非常困难

重复代码——在多个地方执行相同的任务。 由于许多原因，代码重复通常是不好的。 不重复代码的最直接原因是你重复了编写它的努力。 也许更重要的是，它更难维护——如果你需要改变一些你必须记住的东西（或者你的开发团队需要弄清楚）在两个地方改变它。 最后，如果你的代码有错误，你必须在多个地方修复它。

## 分层抽象

抽象是分层工作的——我们可以将系统中最小的“构建块”组合成更大的逻辑单元。 然后我们可以将这些更大的“块”组合成更大的单元，并重复这个过程，直到我们拥有一个大而复杂的系统

设计具有分层抽象的软件主要可以通过两种方式进行： _自底向上_ 或 _自顶向下_ 。 在自下而上的设计中，您首先从最小的构建块开始，然后依次构建更大的组件。 这种方法很适合增量测试（构建一个部件，测试它，构建一个部件，测试它......）。 但是，缺点是您必须确保构建 _正确_ 的块，并且它们最终都可以组合在一起。 #自底向上 #抽象

另一种设计理念是自上而下。 在自上而下，您首先设计最高级别的算法，并确定您需要哪些其他功能来支持它。 然后您继续设计这些功能，直到您达到足够小的功能，您不需要再抽象出任何部分。 这种设计方法听起来应该很熟悉，因为它正是我们在讨论如何将您的通用步骤转换为代码时向您描述的。 这里的好处是您确切地知道每一步需要哪些部分（您已经设计的高级算法需要它们），以及它们如何组合在一起。 #自顶向下 #抽象 

自上而下设计的缺点可能出现在测试中。 如果您尝试编写整个内容，然后对其进行测试，那么您就是在自找麻烦。 但是，如果您以自上而下的方式实现您的算法，您可能拥有依赖于不存在的较低级别部分的高级算法。 **这个问题可以通过几种方式来克服**。

**(在完成适当大小的中等块后对中等块先进行测试)** 首先，您仍然可以在每次构建完整部件时测试您拥有的东西。 也就是说，当你完成一个“小块”时，你可以测试它。 然后，一旦您构建（并测试）了中等大小的所有“小块”，您就可以对其进行测试。 实际上，您正在以自下而上的方式构建和测试代码，即使您已经以自上而下的方式完成了设计（并且可能有一些部分实现/未经测试的高级算法）

**(实现一个硬编码或者简单版的小块)** 解决这个问题的第二种方法是编写 _测试存根_ ——小块的简单实现，这些小块实际上通常不能正常工作，但对用于测试更高级别算法的测试用例表现出正确的行为。 这样的测试存根可以像硬编码响应一样简单（ _例如，_ `if(input==3) {return 42;}` ）。 然后，您可以假设较低级别的部分正常工作，然后再继续实施这些部分，就可以测试您的较高级别的功能。