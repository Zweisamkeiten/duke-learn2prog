---
date created: 2022-10-16 15:30
date updated: 2022-10-16 15:37
---
## 操作系统

交互——从用户那里读取输入、在磁盘上写入文件、通过网络发送数据等——需要以某种方式访问硬件设备（键盘、磁盘驱动器、网卡）正常程序无法自行执行。 这个问题的一个关键方面是不能信任“正常”程序直接访问硬件。 如果您的程序可以直接读取磁盘，那么它可以忽略保护不同用户文件的权限系统，并读取或写入它想要的任何数据。 此外，可以直接访问磁盘的程序中的错误可能会破坏整个文件系统，破坏系统上的所有数据。

_操作系统_ （OS）——负责管理系统上所有程序的所有资源的低级软件——代表它访问硬件。 程序通过 _系统调用_ 发出这个请求——一种特殊类型的函数调用，将控制从程序转移到操作系统。 操作系统在执行之前检查程序的请求是否在其权限范围内，这是系统执行安全规则（例如文件权限）的方式。 如果请求不被允许，操作系统可以向程序返回错误。 另一方面，如果请求正常，则操作系统执行底层硬件操作以使其发生，然后将结果返回给程序。

![](attachments/Pasted%20image%2020221016153810.png)
程序、C 库、操作系统和硬件之间的概念关系

调用 **printf** 将字符串写入标准输出。  **printf** 函数是 C 库的一部分，它涉及不需要系统调用的重要代码：它必须扫描格式字符串中的 % 符号，并执行适当的格式转换，构建要打印的实际字符串。 然而，在某些时候， **printf** 必须实际将结果字符串写入标准输出，这需要系统调用。 为了执行这个任务， **printf** 使用 **write** 系统调用。

系统调用（将控制权转移到操作系统，请求它执行任务）
库调用（调用库中的函数，例如 C 标准库）

## 系统调用的错误

系统调用在许多情况下会失败:
- 尝试读取一个不存在或没有权限的文件
- 尝试连接一个不合法的或者不可到达(网络或远程计算机已关闭)的计算机

在 C 中失败的系统调用, 或者由 C 库封装执行的系统调用会设置一个全局变量 **errno**. ("error number")

全局变量不鼓励使用, 作用域为整个程序的变量. 声明在所有函数之外,且有一个"box", 不属于任何帧的一部分. 

#newget
**errno**, 会被一个失败的调用设置, 并且读取程序中是否需要更多关于调用 _为什么_ 失败的信息. 如果要检查是否发生了特定错误，可以将其与 **errno.h**  中定义的各种常量进行比较。

为用户打印一条描述错误的信息. 只打印 **errno** 的数字值不太有用. C 库提供了一个 **perror** 函数, 根据 **errno** 的当前值打印与之相对应的错误

**perror** 函数接受一个参数，即在其描述性消息之前打印的字符串

由于 **errno** 是全局的（整个程序都有 _一个_ )，因此在测试或调用**perror**前, 必须注意不要调用任何可能更改它的东西 。

```c
//BROKEN CODE
int x = someSystemCall();
if (x != 0) {
	printf("someSystemCall() failed!\n"); //may change errno
	perror("The error was: ");
}
```

在这里， **printf** 可能会更改 **errno** （它会进行系统调用），因此我们可能没有对来自 **perror** 的错误的正确描述。 代码其他部分发生意外更改的可能性是全局变量的危害之一，也是通常避免它们的部分原因。