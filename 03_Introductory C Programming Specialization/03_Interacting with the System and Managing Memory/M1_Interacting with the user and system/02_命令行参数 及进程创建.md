---
date created: 2022-10-16 15:57
date updated: 2022-10-16 16:29
---

## 命令行参数

程序可以通过 _命令行参数_ 的形式输入.

`gcc -o hello hello.c` 将三个参数(-o, hello, hello.c) 传递.

```c
int main(int argc, char ** argv) {
//...whatever code you want goes here...
}
```

**main** 现在有两个参数。 首先， **int argc** (代表**arg**ument **c**ount) 是传入 **计数** 。 第二个是字符串数组，其中包含传入的参数（它代表**arg**ument **v**ector）。 **argv** 的第 0 个元素即 `argv[0]` 是命令行上调用的程序的名称（因此，如果您编写 **./a.out** ，那么 `argv[0]` 是字符序列 `"./a.out\0"`)。

argv[1] 到 argv[argc – 1]

将命令行文本精确划分为离散参数取决于命令 shell，但通常通过在空格处分隔文本来完成（请注意，程序可以由 shell 以外的其他东西调用，在这种情况下，调用程序可以传递它想要的任何参数）。 参数作为文本传入，因此如果程序打算以数字方式解释其中一个参数，则必须将该文本转换为数字。

![](attachments/Pasted%20image%2020221016160337.png)

## 复杂标志选项处理

有些程序执行更复杂的选项处理——采用各种标志和选项，其中一些需要参数（在某些情况下，需要可选参数）

`gcc -o myProgram myProgram.c`

-o **-o** 选项本身带有一个参数——它之后的下一个命令行参数指定输出的确切内容，因为 **就** 在它之前。 但是，gcc 不是必须需要 **-o**, 可以先编写其他参数

对于更复杂的选项处理（例如像 gcc 这样的程序所需要的）， **getopt** 函数非常流行。 **getopt** 是 C 库的一部分，它解析命令行参数，考虑诸如具有（可能是可选的）参数的选项以及短名称和长名称版本（例如，某些程序可能接受短名称，如 **-o** 和一个长名称，如 **--output** 具有相同的含义）。 我们不会在这里详细介绍 **getopt** ，但是如果您需要它，当然可以在其手册页中阅读它（请务必指定 **man -S3 getopt** ，因为在手册页的第 1 节）。[getopt函数理解](../../../others/getopt函数理解.md)
#getopt

#newget

## 环境指针

与命令行参数相比不太常用, **main** 函数可以接收第三参数 **char **envp**, 是一个指针指向一个字符串数组(包含环境变量的值). 如果程序需要检查环境变量, 可以使用这第三个参数.

字符串数组的组成形式 _variable=value_,(e.g., _PATH=/bin:/usr/bin_).

您还可以使用函数 **getenv** 、 **setenv** 、 **putenv** 和 **unsetenv** 访问环境变量。 有关详细信息，请参阅他们的手册页。

#进程创建 #newget

## 进程创建

简要介绍进程的创建. 当 _command shell_ (或者其他程序- command shell 只是一个普通程序)想要运行另外一个程序, 它使用了一系列系统调用.

1. **fork** 创建一个新进程(是原始的相同副本copy, 唯一区分它们是通过 fork 系统调用的返回值)
2. **execve** 用被请求的程序取代它正在运行的程序. **execve** 接收一个参数指定一个二进制程序(或者一个脚本)去运行, 第二个参数指定传入给新程序 **argv**(必须是 一个 NULL 结尾)的所有值, 第三个参数指定传入给 **envp**(即使 main 函数忽略了 **envp** , 这些值仍可以传递给新程序, 因此它们可以被上一小节中提到的各种环境操作函数访问) 的值
3. **execve** 系统调用 destroy 摧毁正在运行的程序 (execve该系统调用只会在发生错误是返回), 加载指定的可执行二进制文件到内存中. 它将 **argv** 和 **envp** 的值以预先约定的格式写入内存（ABI 的一部分——应用程序二进制接口：操作系统和程序之间关于事物如何工作的契约）。 然后内核将执行箭头设置到可执行二进制文件中指定的起始位置（在带有 gcc 的 Linux 上，入口点是一个名为 `_start` 的符号——但细节是特定于平台的）。
4. 该启动代码（位于与您编译的任何 C 程序链接的目标文件中 - 除非您明确要求它不存在）然后调用初始化 C 库的各种函数。 此启动代码还计算 argv 的元素以计算 argc 的值并最终调用 main。 不管 main 是如何声明的，它总是传入 argc、argv 和 envp——如果 main 声明的参数较少，它仍然会接收它们但只是忽略它们。
5. 当 main 返回时，它像所有其他函数一样返回到调用它的函数。 在 main 的情况下，调用者就是这个启动代码。 该代码然后执行 C 库所需的任何清理，并调用 exit（退出程序），将 main 的返回值作为 exit 的参数传递——它指定程序的退出状态。
6. _The shell_ (或者其他运行该程序的程序)将使用一个系统调用(等待该子进程退出, 并收集它们的返回值),
