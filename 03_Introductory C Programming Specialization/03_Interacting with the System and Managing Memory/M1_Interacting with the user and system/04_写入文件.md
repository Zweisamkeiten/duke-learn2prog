---
date created: 2022-10-17 09:29
date updated: 2022-10-17 13:35
---

## 写入文件

**fprintf** 函数,  接受一个额外的参数, `File *`, 指定写入的输出位置.

**fputc** 一次写入一个单独的字符.
**fputs** 以没有格式转换的形式写入一个字符串(`fputs("%d")`将只直接打印"%d")

**fwrite** 打印非文本数据

```c
size_t fwrite(const void *ptr, size_t size, size_t nitems, FILE * stream);
```

这些写入文件的方法中的任何一种都可能失败，其中一些会立即检测到，而另一些会稍后检测到。

稍后可能会检测到故障的原因是 C 库函数可能会缓冲数据，而不是立即请求操作系统写入数据。即使应用程序进行了必要的系统调用来写入数据，操作系统也可能会在内部缓冲一段时间，然后再将其实际写入底层硬件设备。 不立即写入的动机是性能：进行系统调用是一个有点慢的过程，写入硬盘非常慢。 此外，当您向磁盘写入较少量的数据时，写入磁盘的效率会降低——在磁盘上找到可以通过大量写入摊销的位置的固定开销是固定的——因此操作系统会尝试缓冲写入直到有大量数据可以一次写出来。

## 关闭文件

当完成对文件的操作, 需要使用 **fclose** 关闭文件

```c
int fclose(FILE * stream);
```

关闭流会发送所有缓存的写入数据到操作系统, 然后请求操作系统关闭相关联的文件描述符. 在流上调用 **fclose** 后，无法再访问它.

**fclose** 返回一个 int, 该返回值表示成功(返回0)或失败(返回EOF，并 **相应设置errno** ) . 有很多原因会导致失败, 最严重的原因是数据实际上无法写入底层硬件设备（ _例如_ 磁盘驱动器）的情况，例如磁盘已满或文件驻留远程文件系统和网络连接已丢失

对已经写入的文件, 关闭文件失败是一种严重的情况——这意味着您的程序尝试写入的数据可能会丢失.  **因此，应该始终检查fclose的返回值** 以查看它是否失败

对 **fclose** 失败的响应是一个有点困难的问题。 不能再试一次，因为对尝试关闭的流执行任何操作（包括对 **fclose** 的另一次调用）都是错误的（并导致未定义的行为）

告知保存失败（以及原因）。 然后，用户可以继续释放磁盘空间，并再次保存（这将涉及再次 **fopen** 文件、 **fwrite** fclose 所有数据、 **原始**那个流——而不是重新尝试 **fclose** 流)

养成检查其返回值的习惯

## 其他交互

有时程序与系统的其余部分或外部世界交互的方式不是读取或写入文件。 UNIX 试图使尽可能多的这些访问类型看起来与访问文件相似——呈现相同的界面，从而允许使用熟悉的函数来执行这些操作。 对于符合此模型的操作，启动访问的底层系统调用返回一个文件描述符，然后将其传递给其他适当的系统调用（例如 **read** 或 **write** _）_

如果用户想要使用来自 **stdio** 的 IO 函数（ **fprintf** 、 **fgets** 、 **fgetc** 、...），她可以使用 **fdopen** 库调用来获取  与文件描述符对应的`FILE *`.

“看起来像文件”的交互示例之一是读取用户的输入并将其打印到终端。 使用 **printf** 将内容打印到终端，它将输出打印到 **stdout** ， `FILE *` 是一个连接到“标准输出”的文件描述符

可以使用 **fprintf** 打印到 **stderr** ，这是另一个 `FILE *` 默认情况下也会进入终端的

可以通过从终端读取 **stdin** 来获取用户的输入

这些 `FILE *` 中的每一个都在 **stdio.h** 中声明。 当程序启动时它们都是打开的（C 库在 **main** 之前打开它们），它们对应于文件描述符 0（ **stdin** ）、1（ **stdout** ）和 2（ **stderr** ）。 永远不应该关闭这些文件 `* s`，因为 C 库负责它们，而不是我们的代码

另一个“看起来像文件”的交互示例是通过网络传输数据。该程序 _获取套接字_ 的文件描述符, 套接字是数据传输的逻辑抽象--通过套接字系统调用.

根据程序所需的网络协议，可能需要额外的设置来指定目的地、建立连接等。但是，一旦设置了套接字，就可以使用 write 系统调用通过套接字发送数据，或者通过使用 read 系统调用从网络读取数据（如果没有接收到数据，它将 _阻塞_ ——导致程序等待——直到数据到达）。 当然，如果 fdopen 系统调用已用于设置 `FILE *`，则 **可以使用fprintf** 或 **fgets** 之类的库函数（它们对底层文件描述符进行写入和读取系统调用）

另一种看起来像文件的交互形式是 _管道_ 。 “管道”这个名称可能听起来 **类似shell 结构（如 shell 中的cmd1 | cmd2)** 。 管道是两个进程之间的单向通信通道。 一个进程将数据写入管道的一个“端”，而另一个进程从管道中读取数据，获取第一个进程写入的数据（如果没有可用数据则阻塞）。 这种通信看起来与向每个进程读/写文件完全一样（因为它们再次 读/写 文件描述符，或使用这样做的库函数）。在shell中, 使用管道运算符时，shell 会使用它，因为它设置了一个管道，并将第一个进程的标准输出文件描述符安排为管道的写入端，并将第二个进程的标准输入文件描述符安排为成为管道的读取端。

在 Linux 上，文件 _/dev/random_ 提供对内核提供的安全伪随机数生成器的访问.
打开此文件以进行读取 **可以使用fopen** （或 **open** ，并使用任何方法从中读取。 但是，当对该文件执行读取操作时，内核会认识到它应该执行一个随机数生成例程来提供数据，而不是读取磁盘。 内核将根据其算法生成随机数，并将其作为系统调用读取的数据返回。 如果内核的熵模型指示它需要更多的熵来安全地生成数字，则读取操作可能会阻塞。 _/ dev/urandom_ [2原因](#^0e9f96) 设备可用于使用相同算法生成数字，但不考虑是否有足够的熵可用于安全敏感目的。

有些东西不适合“一切都是文件”模型。 这些通常由系统调用处理，但可能不涉及文件描述符。 例如，如果您需要您的程序确定当前时间，您可以使用 **gettimeofday** 系统调用，它只返回一天中的时间。 还有用于创建新进程(**fork**)替换当前正在运行的程序的**系统调用**，取而代之为另一个(**execve**) ，退出当前程序(**exit**) 是通常用于此目的的库调用， `_exit` 提供对底层系统调用的访问，这是很少需要的. 还有更多的东西。 事实上，有几百个系统调用。 随着您获得编程经验，您会更加熟悉它们。

默认情况下，大多数信号对程序都是致命的——如果操作系统需要向程序传递致命信号，它将杀死相关程序。 我们已经看到了一个致命信号的例子——尽管我们没有将它作为一个信号进行讨论。 当您的程序段错误（当您的程序以某些无效方式访问内存时发生）时，操作系统会向它发送 **SIGSEGV**，这会杀死程序。 其他一些信号具有被忽略的默认操作，在这种情况下，如果操作系统传递该信号，则不会发生任何事情。

程序可以更改接收每个特定信号后做的事情(信号 9 除外，它是 SIGKILL，它总是致命的). 信号新行为的一种选择是让操作系统使程序运行特定功能(程序在进行系统调用时指定哪个函数,要求操作系统修改其对该信号的行为)。 我们会注意到，将您的程序设置为忽略 SIGSEGV，因为您无法让它工作（并且它会不断出现段错误）是一个坏主意——请记住，您永远不想隐藏错误，您总是想修复它。

内核通常通过跟踪它可以观察到的事件中难以预测的信息（例如内核必须处理的硬件事件之间的微秒数，例如按键、鼠标移动或通过网络到达的数据）来生成熵接口），这是伪随机数生成的基础。 随着数字的生成，在没有新的难以预测的事件为算法提供信息的情况下，猜测有关模式的信息可能成为可能，因此内核在提供更多数字之前等待更多此类事件。 ^0e9f96
