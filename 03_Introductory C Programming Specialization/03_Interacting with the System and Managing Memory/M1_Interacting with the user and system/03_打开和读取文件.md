---
date created: 2022-10-16 16:48
date updated: 2022-10-16 22:38
---

## 打开文件

打开文件会出现一个文件流. `FILE *` 是一个数据的序列(在此时是 **char**s), 可以被读取或者修改.

流具有当前位置，该位置通常可以在对流执行读取或写入操作时前进（并且可能由程序任意移动，也可能不移动，具体取决于流与什么相关联）

使用 **fopen** 函数打开一个文件

```c
FILE * fopen(const char * filename, const char * mode);
```

两个参数，第一个是要打开的文件的名称。 此文件名是一个字符串（必须以空终结符结尾，并且不被 **fopen** 修改），它是要打开的文件的路径名。 路径名可以是绝对路径（以 / [正斜杠] 开头），也可以是相对于程序当前工作目录的路径。
第二个参数是文件的模式——是否应该打开文件进行读取和/或写入，如果文件不存在是否创建文件，是否清除现有内容，以及从什么位置访问文件开始。 参数传递字符串文字（例如"r"）作为模式（尽管任何计算结果为有效字符串的表达式当然是合法的）

下图显示了用 _fopen_ 打开文件时会发生什么，并将生成的 `FILE *` 分配给名为 **f** 的变量这里对 FILE 的描述是概念性的，因为实际的结构要复杂得多，并且不直接包含文件中的数据。 但是，我们不需要知道实际的 FILE 结构包含什么，只需要知道如何对其进行操作。 事实上，即使我们确实知道 某个特定系统上的 FILE 结构中的内容，我们也不应该尝试使用这些信息直接访问其中的字段，因为实现细节取决于系统，因此我们的代码不是可直接移植的。

![](attachments/Pasted%20image%2020221016165325.png)

顶部显示了有关文件状态的一些信息（打开了哪个文件，是否可以读取或写入，以及程序是否尝试读取文件末尾）。 底部显示文件中的数据，以及流的位置（由蓝色光标指示）。 读写操作将发生在当前位置（ _即_ 这个蓝色光标），并会推进它。

真正的 FILE 结构不包含文件名，而是 _文件描述符_ ——当程序进行系统调用以打开文件（即 **打开** 系统 ）时操作系统返回给程序的数字标识符称呼）。 对流进行操作的 C 库函数将此描述符传递给相关系统调用，这些系统调用为它们执行底层输入/输出操作。

可能 **fopen** 会失败——例如，您请求的文件可能不存在，或者您可能没有访问它所需的权限。 每当 **fopen** 失败时，它都会返回 NULL（并适当地设置 **errno** 的返回值). 在尝试使用流之前，**您应该始终检查fopen** 是否为 NULL 或有效流。

![](attachments/Pasted%20image%2020221016165550.png)
![](attachments/Pasted%20image%2020221016165629.png)

第四列显示如果文件已经存在，文件的内容是否被截断为零长度——即文件的现有内容是否被丢弃。

对于 a 模式（代表追加），所有写入都将其数据写入文件末尾，即使程序明确地将当前位置移动到其他位置。

## 读取文件

**fgetc**, **fgets**, **fread**.

#fgetc
**fgetc** 一次读取一个字符, 返回一个整型以便于 返回所有可能的字符以及一个独特的值(**EOF**)来指示流中没有更多的可用字符, 文件的结尾已到达. 在 **stdio.h** 中定义了 文件结尾的值的常量 **EOF**. 读取字符会推进流中的当前位置.

### Reading a File with fgetc

```c
int fgetc(FILE *stream);
```

从流中读取的函数会推进流的位置这一事实在编写循环时会造成轻微的烦恼。 考虑以下（损坏的）代码，它尝试打印输入文件中的每个字符：

```c
//broken

FILE * f = fopen(inputfilename, "r");
if (f == NULL) { /* error handling code omitted */ }
while (fgetc(f) != EOF) {
	char c = fgetc(f);
	printf("%c",c);
}
//...other code...
```

此代码将读取一个字符，检查它是否是文件的结尾，然后读取 _另一个_ 字符并打印它。
实际上是打印了所有偶数位上的字符,最后可能加上一些虚假内容(如果文件中有奇数个字符)

重构循环的最简洁的方法是利用赋值也是一个表达式，它计算出所分配的值。

```c
//fixed
FILE * f = fopen(inputfilename, "r");
if (f == NULL) { /* error handling code omitted */ }
int c;
while ( (c=fgetc(f)) != EOF ) {
	printf("%c",c);
}
//...other code...
```

将该赋值语句包装在括号中以确保正确的操作顺序，并将分配的值（无论 fgetc 返回什么）与 EOF 进行比较

c 的类型是 **int** ，而不是 **char**. **fgetc** 返回一个 int ，以便它可以返回从文件中读取的任何可能的字符值，以及一些不同的 EOF 值. #important

将此返回值分配给 char 会固有地丢弃信息——我们将获取 N + 1 个可能的值并将它们分配给可以保存 N 个不同位模式的东西（在 char 的情况下，N = 256）。 在大多数系统上，EOF 为 –1，因此在这种特殊情况下，我们将无法区分读取字符号 255 和文件结尾——如果我们的输入中包含字符号 255，我们的程序将过早退出循环，并忽略输入的其余部分！

#fgets

### Reading a File with fgets

一次读取一行(具有最大长度)

```c
char * fgets(char * str, int size, FILE * stream);
```

这个函数接受三个参数。 第一个是指向数组的指针，其中存储从文件中读取的字符。 也就是说， **fgets** 会将数据写入 **str[0], str[1], str[2]** ,... 第二个参数指定有多少空间可供它写入数据。 也就是说， **size** 指定数组 **str** 的大小。 最后一个参数指定从哪个流读取数据。

此函数返回 **str** 如果成功（读取数据没有错误）**在这种情况下， str** 中的数据以空值结尾。

如果失败，则返回 NULL — 如果在读取任何数据之前遇到文件末尾，或者遇到其他错误。

如果需要区分错误和文件结尾，您应该使用 **feof** 和/或 **ferror** 函数，它们指定是否尝试读取文件结尾，或者是否分别发生了其他错误

重申不应该 _使用_ gets **函数**。 这个函数的行为有点类似于 **fgets** _，_ 但不接受一个参数来指定它读入的数组的大小。 这种疏忽意味着它将继续读取数据，直到它到达换行符，即使它写入超出了数组的边界（它无法判断它有多大）。 因此， **gets** 函数存在重大的安全漏洞，因为它容易受到缓冲区溢出的影响。

## Reading a File with fread

#fread

从文件中读取非文本数据
可能有一个图像、视频、声音或其他文件，我们在其中以二进制格式写入数据。 在这样的文件中，不是写入整数的文本表示，而是将整数的实际字节写入文件。 用于每条数据的特定整数大小是文件格式规范的一部分。 当我们想以这种方式读取数据时，最合适的函数是 **fread** ，它的原型如下

```c
size_t fread (void * ptr, size_t size, size_t nitems, FILE * stream);
```

第一个参数是指向要写入的数据的指针——它是一个 `void *` ，因为它可以是任何类型的数据。
下一个参数指定每个项目的大小。 也就是说，如果我们正在编写一个 int 或一个 int 数组，我们将传入 `sizeof(int)`。 但是，如果我们正在读取和写入文件，我们可能希望使用 中**stdint.h**定义的 int 类型，它们的大小在系统之间是固定的（例如 **int32_t** 或 **uint64_t** ）
第三个参数指定应该从流中读取多少这样的项目
最后一个参数指定从哪个流中读取
**fread** 函数返回成功读取的项目数
与 **fgets** 一样 ，如果fread返回的项目少于您的要求, 您应该使用 **feof** 和/或 **ferror** 来获取更多信息

#fscanf
**fscanf** 读取格式化输入, 执行与 **printf**相反的格式化转换, 把数据赋予变量
不过下面这种方法更容易处理错误. 使用 fgets（getline）然后对结果字符串使用 sscanf，通常更容易处理错误。 fgets（getline）将一次读取一行，然后可以尝试将结果转换出来，因为可能有也可能没有所需的格式。 在这种情况下，可以轻松地继续读下一行。相反， **fscanf** 将在遇到与请求格式不匹配的内容时立即停止读取输入。 如果您想从下一行继续阅读，则必须在继续之前明确读出该行的其余部分
